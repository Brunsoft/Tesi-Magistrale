% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%*******************************************************
% Introduzione
%*******************************************************
\cleardoublepage
\pdfbookmark{Introduzione}{introduzione}

\chapter{Introduzione}
Prima dell'arrivo di Bitcoin erano decenni che circolava l'idea di una moneta digitale decentralizzata, la creazione di Bitcoin non fu quindi frutto della genialità di una singola persona, quanto piuttosto il risultato di un cammino che prese l'avvio con la diffusione delle tecnologie digitali cercando di giungere ad una soluzione che fosse in grado di bilanciare efficienza, sicurezza e decentralizzazione. Da questo punto di vista Bitcoin non appare più come una sorta di "Big Bang", ma come un processo darwininiano di lenta selezione, partito da molto lontano. 

Alla fine degli anni '80 David Chaum creò DigiCash che prevedeva una valuta tokenizzata il cui trasferimento poteva avvenire da persona a persona in modo molto simile all'attuale Bitcoin. Venne definita una Blinding Formula che confermava la legittimità e l'esistenza del token impedendo, inoltre, la tracciabilità, da cui il termine Blinding cash. 

Successivemente Nick Szabo cercò di lanciare Bit Gold, una valuta digitale decentralizzata in cui per la prima volta si poneva l'accento sulla distribuzione comunitaria della valuta e sulla creazione di un algoritmo di proof-of-work per limitarne la produzione ed evitare fenomeni inflazionistici. Questo progetto è stato da molti definito il diretto precursore dell'attuale Bitcoin ma non fu mai implementato.

Un altro esperimento di moneta digitale prima dell'avvento di Bitcoin e basato su un primo tentativo di proof-of-work, fu HashCash. Si trattava di una valuta digitale che per un certo tempo ebbe anche successo, si poneva come obiettivo anche la capacità di resistere ad attacchi tra cui quelli di DDOS. L'uso di una forma di proof-of-work doveva anche limitarne la distribuzione. Ciò che portò alla decadenza di HashCash fu il superamento dell'algoritmo di PoW da parte della capacità di elaborazione di quel periodo, che ne portò all'iperinflazione.

L'innovazione fornita da Satoshi Nakamoto, pubblicata nel 2008 nel suo paper \cite{paper-bitcoin:satoshi}, è l'idea di riuscire a combinare un protocollo molto semplice basato su dei nodi su cui avvengono le transazioni, che danno vita ad una sempre crescente blockchain, attraverso la creazione di "blocchi" ogni 10 minuti, con il proof-of-work come meccanismo attraverso cui i nodi guadagnano il diritto di partecipare al sistema. Il modello blockchain Bitcoin, che analizzeremo nel dettaglio nel capitolo \ref{bitcoin-chapter}, ha dimostrato di essere sufficientemente valido, e nel corso dei successivi anni sembra diventato il fondamento di numerose monete e protocolli di tutto il mondo. 

Nasce qui la necessità di creare un protocollo alternativo per la creazione di applicazioni decentralizzate fornendo un insieme eterogeneo di possibilità che, saranno utili per una larga classe di applicazioni decentralizzate, in particolar modo nelle situazioni dove sono essenziali: un tempo rapido di sviluppo, la sicurezza per applicazioni utilizzate di rado, e la capacità di far interagire tra loro, in modo molto efficace, applicazioni differenti. Ethereum, che analizzeremo in tutte le sue parti nel capitolo \ref{ethereum-chapter}, permette tutto ciò attraverso la costruzione di quello che in sostanza è un protocollo definito come una Blockchain con un linguaggio di programmazione, costruito al suo interno e turing-completo, che permette ad ognuno di scrivere degli smart contracts e delle applicazioni decentralizzate dove stabilire le proprie regole arbitrarie per la proprietà, i formati delle transazioni e le funzioni di transizione di stato. Il codice nei contratti Ethereum è scritto in un linguaggio di basso livello, linguaggio bytecode a cascata, denominato "codice virtual machine Ethereum" o "codice EVM". Il codice consiste in una serie di bytes, dove ogni byte rappresenta un'operazione. Per la stesura di questi smart contract, il programmatore necessita di un linguaggio object-oriented e di alto livello, che nel caso di Ethereum è rappresentato da Solidity. Questo nuovo linguaggio di programmazione è in continua evoluzione proprio per il fatto che esiste da poco tempo, generando aggiornamenti cumulativi. Questi continui cambiamenti portano ad una inevitabile procedura di aggiornamento da parte del programmatore designato che dovrà essere a conoscenza delle novità apportate da ogni nuova versione del compilatore Solidity, attualmente escono in media 4 versioni nightly a settimana. 

Nasce anche da qui la necessità di creare un framework che permetta di sfruttare le competenze e gli strumenti, già definiti e strutturati nel tempo, del linguaggio di programmazione Java con il fine di permettere lo sviluppo di smart contract in modo semplice e confortevole, utilizzando gli strumenti esistenti. Questo nuovo framework, descritto nel paper \cite{paper-takamaka:spoto} scritto dal Prof. Nicola Fausto Spoto, prende il nome di Takamaka ed utilizza appunto un sottoinsieme delle librerie Java. L'utilizzo di questo linguaggio per la programmazione di una blockchain non risulta affatto immediato, infatti questa scelta porta con sè una serie di problematiche legate al determinismo, non possiamo infatti permettere l'esecuzione di una procedura che dia risultati differenti su macchine differenti. Un risultato di questo tipo sarebbe infatti disastroso su qualsiasi blockchain. Si dovrà quindi procedere con la definizione di un sottoinsieme di librerie \textit{white-listed} che rappresenteranno le sole utilizzabili all'interno dei contratti scritti con tale framework.

Lo scopo di questo elaborato è la ricerca dei metodi, all'interno delle esistenti librerie Java, che possono in qualche modo comportarsi in modi non deterministici, documentandone il loro scopo e i casi in cui tali metodi possono comportare in modi non prevedibili. Per ogni metodo si dovrà arrivare a delle conclusioni, immaginandone utilizzo all'interno di appositi metodi di contratto. Questo tipo di analisi ci porterà a concludere quando e come certi metodi possano essere utilizzati arrivando ad escludere completamente l'utilizzo di alcuni e vietando l'uso di altri solo in determinate condizioni. Tutta questa analisi, completa di esempi, è possibile trovarla al capitolo \ref{metodi-java-non-deterministici}.