% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%*******************************************************
% Introduzione
%*******************************************************
\cleardoublepage
\pdfbookmark{Introduzione}{introduzione}

\chapter*{Introduzione}
Prima dell'arrivo di Bitcoin erano decenni che circolava l'idea di una moneta digitale decentralizzata. I protocolli anonimi di moneta digitale degli anni '80 e degli anni '90 si basavano soprattutto su una crittografia conosciuta come Chaumian blinding, furono rilasciati da una moneta con un alto tasso di privacy. Tuttavia questi fallirono principalmente per non essere riusciti a guadagnare terreno, a causa della loro dipendenza da un intermediario centralizzato. Nel 1998, Wei Dai's b-money\footnote{http://www.weidai.com/bmoney.txt} divenne il primo progetto ad introdurre l'idea di creare una moneta attraverso la soluzione di puzzle computazionali assieme al consenso decentralizzato, tuttavia il progetto non offriva sufficienti dettagli su come questo consenso decentralizzato potesse essere concretamente attualizzato. Nel 2005, Hal Finney introdusse il concetto del "proofs of work riutilizzabile", un sistema che utilizza le idee provenienti dalla b-moneta, insieme ai puzzle computazionali Hashcash proposto nel '97 da Adam Back, per creare un concetto di criptomoneta, ma, ancora una volta, non si riuscii ad ottenere il suddetto fine. Poiché la moneta è un'applicazione first-to-file, dove l'ordine delle transazioni è spesso di cruciale importanza, le monete decentralizzate richiedono una soluzione al consenso decentralizzato. 

L'innovazione fornita da Satoshi Nakamoto, pubblicata nel 2008 nel suo paper \cite{paper-bitcoin:satoshi}, è l'idea di riuscire a combinare un protocollo molto semplice basato su dei nodi su cui avvengono le transazioni, che danno vita ad una sempre crescente blockchain, attraverso la creazione di "blocchi" ogni 10 minuti, con il proof of work come meccanismo attraverso cui i nodi guadagnano il diritto di partecipare al sistema. Il modello blockchain Bitcoin, che analizzeremo nel dettaglio nel capitolo \ref{bitcoin-chapter}, ha dimostrato di essere sufficientemente valido, e nel corso dei successivi anni sembra diventato il fondamento di numerose monete e protocolli di tutto il mondo. 

Nasce qui la necessità di creare un protocollo alternativo per la creazione di applicazioni decentralizzate fornendo un insieme eterogeneo di possibilità che, saranno utili per una larga classe di applicazioni decentralizzate, in particolar modo nelle situazioni dove sono essenziali: un tempo rapido di sviluppo, la sicurezza per applicazioni utilizzate di rado, e la capacità di far interagire tra loro, in modo molto efficace, applicazioni differenti. Ethereum, che analizzeremo in tutte le sue parti nel capitolo \ref{ethereum-chapter}, permette tutto ciò attraverso la costruzione di quello che in sostanza è un protocollo definito come una Blockchain con un linguaggio di programmazione, costruito al suo interno e Turing-complete, che permette ad ognuno di scrivere Smart Contracts ed applicazioni decentralizzate dove stabilire le proprie regole arbitrarie per la proprietà, i formati delle transazioni e le funzioni di transizione di stato. Il codice nei contratti Ethereum è scritto in un linguaggio di basso livello, linguaggio bytecode a cascata, denominato "codice virtual machine Ethereum" o"codice EVM". Il codice consiste in una serie di bytes, dove ogni byte rappresenta un'operazione. Per la stesura di questi Smart Contract il programmatore necessita di un linguaggio object-oriented e di alto livello, che nel caso di Ethereum è rappresentato da Solidity. Questo nuovo linguaggio di programmazione è in continua evoluzione proprio per il fatto che esiste da poco tempo generando aggiornamenti cumulativi. Questi continui cambiamenti portano ad una inevitabile procedura di aggiornamento da parte del programmatore designato che dovrà essere a conoscenza delle novità apportate da ogni singola nuova versione del compilatore Solidity, attualmente escono in media 4 versioni nightly a settimana. 

Nasce anche da qui la necessità di creare un framework che permetta di sfruttare le competenze e gli strumenti, già definiti e strutturati nel tempo, del linguaggio di programmazione Java con il fine di permettere lo sviluppo di smart contract in modo semplice e confortevole, utilizzando gli strumenti esistenti. Questo nuovo framework, descritto nel paper \cite{paper-takamaka:spoto} scritto dal Prof. Nicola Fausto Spoto, prende il nome di Takamaka ed utilizza appunto un sottoinsieme delle librerie Java. L'utilizzo di questo linguaggio per la programmazione di una blockchain risulta affatto immediato, infatti questa scelta porta con sè una serie di problematiche legate al determinismo, non possiamo infatti permettere che l'esecuzione di una procedura che dia risultati differenti su macchine differenti. Un risultato di questo tipo sarebbe infatti disastroso su qualsiasi blockchain. Si dovrà quindi procedere con la definizione di un sottoinsieme di librerie \textit{white-listed} che rappresenteranno le sole utilizzabili all'interno dei contratti scritti con tale framework.

Lo scopo di questo elaborato è la ricerca dei metodi, all'interno delle esistenti librerie Java, che possono in qualche modo comportarsi in modi non deterministici, documentandone il loro scopo e i casi in cui tali metodi possono comportare in modi non prevedibili. Per ogni metodo si dovrà arrivare a delle conclusioni, tramite alcuni casi di utilizzo di tali metodi all'interno di appositi metodi di contratto. Questo tipo di analisi ci porterà a concludere quando e come certi metodi possano essere utilizzati arrivando ad escludere completamente l'utilizzo di alcuni e vietando l'utilizzo di altri solo in determinate condizioni. Tutta questa analisi, completa di esempi, è possibile trovarla al capitolo \ref{metodi-java-non-deterministici}.