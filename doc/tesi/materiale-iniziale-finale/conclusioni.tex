% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%*******************************************************
% Conclusioni
%*******************************************************
\cleardoublepage
\pdfbookmark{Conclusioni}{conclusioni}

\chapter*{Conclusioni}
Nel capitolo \ref{bitcoin-chapter} di questo elaborato si sono analizzate le caratteristiche tecniche che permettono il funzionamento di Bitcoin, in particolare della blockchain, un registro distribuito il cui accesso è aperto a chiunque, lo scopo di tale registro è il mantenere traccia di tutte le transazioni risolvendo, senza la necessità di un’autorità centrale, il problema del double-spending. Il fatto che la blockchain sia di pubblico dominio implica l’impossibilità di una sua manomissione, rafforzata dal fatto che la blockchain risulta di fatto un'ordinata lista di blocchi contenenti transazioni back-linked\footnote{I variblocchi sono collegati a ritroso, ognuno si riferisce al precedente blocco presente nella catena.}, questi aspetti rappresentano sicuramente gli elementi più innovativi di tale sistema. Questo nuovo approccio portato da Bitcoin sembra in grado di rivoluzionare tutti i sistemi di gestione centralizzata a cui siamo abituati. Abbiamo inoltre analizzato il funzionamento della \textit{proof-of-work} con particolare attenzione alla funzionalità di \textit{retargeting} implementata da Bitcoin che mantiene costante l'emissione della valuta aumentando la difficoltà dell'algoritmo di \textit{proof-of-work} in base all'ormai veloce aumento della potenza di calcolo degli elaboratori che prendono parte alla rete. \`E stato inoltre analizzato il processo di fork della blockchain, possibilità non molto remota dovuta al fatto che più miner possono arrivare quasi simultaneamente ad una soluzione dell'algoritmo di \textit{proof-of-work} che causa la creazione di $n$ figli del penultimo blocco. Questo fatto implica la creazione di $n$ versioni di questo libro mastro sul quale lavoreranno $n$ porzioni della rete globale. Da questo punto in poi il primo miner che riuscirà ad inserire un ulteriore blocco all'apice di una delle $n$ chain renderà quella la catena principale sulla quale tutta la rete dovrà lavorare da questo momento in poi. Abbiamo visto che è su questo funzionamento che si basa l'attacco al consenso chiamato \textit{Attacco del 51\%}. Questa tipologia di attacco può essere attuata da un gruppo di miner, appunto almeno il 51\% della rete, che controllano quindi il 51\% della potenza hashing della network mondiale. Abbiamo visto che questa tipologia di attacco può causare deliberatamente dei fork, causare double-spending o eseguire attacchi di denial-of-service contro specifiche transazioni/indirizzi. La percentuale che viene riportata nel nome dell'attacco in questione non richiede per forza il 51\% della potenza di hashing ma tale soglia rappresenta solamente il livello al quale tale attacco è quasi sicuramente possibile. Tale limite sembra infatti essere possibile anche con solo il 30\% della potenza di hashing mondiale.

Nel capitolo \ref{ethereum-chapter} abbiamo analizzato l'alt-chain Ethereum il cui vero scopo non è quello di realizzare un nuovo sistema monetario ma la sua blockchain include anche una valuta che viene emessa come token per allocare dei contratti. Ethereum risulta quindi un'infrastruttura open-source, globalmente decentralizzata, sviluppata per eseguire contratti denominati \textit{smart contract}. Tutti questi contratti e il relativo stato del sistema risiedono sulla blockchain che è di fatto utilizzata per sincronizzare e tenere memoria le modifiche di questo stato assieme alla criptovaluta \textit{ether} utilizzata per limitare l'esecuzione di questi contratti. Ethereum, a differenza di Bitcoin, che presenta un linguaggio di scripting molto limitato, è stato concepito per essere una blockchain programmabile i cui contratti vengono eseguiti da una macchina virtuale \textit{EVM} in grado di eseguire codice di complessità arbitraria. Bitcoin è stato volutamente vincolato a delle semplici valutazioni true/false delle varie condizioni di spesa mentre il linguaggio Ethereum risulta Turing-completo. Questo fatto porta con se una conseguente problematica cioè il fatto che possa eseguire qualsiasi programma di qualunque complessità. Questa capacità porta con se alcuni problemi dal punto di vista della sicurezza e della gestione delle risorse disponibili. Turing ha infatti dimostrato che non è possibile prevedere se un dato programma terminerà o meno senza eseguirlo. Se per caso o di proposito fosse possibile sottoporre ad Ethereum uno smart contract che una volta lanciato non giunga ad un termine si verificherebbe un attacco di tipo DoS. Abbiamo quindi visto che Ethereum risolve questa problematica introducendo un meccanismo di misurazione delle risorse chiamato \textit{gas}. Ogni istruzione ha un proprio costo predeterminato in \textit{gas} e l'esecuzione di una sequenza di istruzione consumerà una certa quantità di \textit{gas}. Abbiamo visto quindi che quando una transazione attiva l'esecuzione di un contratto deve includere una quantità di \textit{gas} impostata ad come il limite superiore di ciò che può essere consumato per l'esecuzione di tale contratto. Abbiamo poi definito il termine smart contract non definendoli tramite la traduzione letterale "contratti intelligenti" ma bens' descrivendoli come contratti che si riferiscono a programmi informatici immutabili che funzionano in modo deterministico in un contesto quale la macchina virtuale EVM e sul computer decentralizzato Ethereum. In questa affermazione troviamo la parola chiave \textit{deterministico}. L'esito di uno smart contract dovrà essere sempre lo stesso per tutti coloro che lo eseguiranno, dato il contesto della transazione e lo stato dalla blockchain Ethereum al momento dell'esecuzione. \`E stato poi analizzato il linguaggio di programmazione contract-oriented che prende il nome di Solidity creato ad Gavin Wood il cui principale prodotto risulta il compilatore \textit{solc} che converte appunto programmi scritti in Solidity in linguaggio bytecode per l'EVM. Di questo linguaggio vengono rilasciate nuove versioni in poco tempo, in questo momento vengono rilasciate delle patch, quattro volte a settimana. Le versioni di Solidity seguono il modello semantic versioning il quale specifica la versione strutturandola in tre parti numeriche: MAJOR:MINOR:PATCH. Una delle caratteristiche principali degli smart contract Ethereum è la loro capacità di richiamare e quindi riutilizzare codice all'interno di altri contratti. A volte però si potrebbe avere la necessità di accedere a delle informazioni al di fuori della blockchain come per esempio informazioni sul meteo piuttosto che sull'andamento finanziario di qualche bene. \`E proprio in questo frangente che ci vengono incontro gli oracoli che sono di fatto in grado di fornire fonti di dati esterne agli smart contract Ethereum. Idealmente questi sono sistemi \textit{trustless} nel senso che sono sistemi decentralizzati che non hanno bisogno di essere fidati. Dal momento che non può esistere alcuna fonte di casualità per l'EVM e per gli smart contract, tali valori dovranno essere introdotti tramite l'utilizzo di un oracolo che procederà con la creazione di una transazione la quale salverà tali informazioni casuali sulla blockchain. Solo in questo momento si potrà procedere con l'utilizzo di tali dati per i propri fini. Se così non fosse, l'esistenza di una funzione casuale all'interno della blockchain, potrebbe portare ad effetti disastrosi portando due differenti nodi che eseguono lo stesso contratto ad concludere risultati differenti nonostante entrambi i nodi abbiano eseguito il medesimo codice. Se questo accadesse non ci sarebbe modo per la rete di arrivare ad un consenso condiviso decentrato. Gli oracoli sono quindi visti come un meccanismo per colmare il divario tra il mondo off-chain e gli smart contract.

Nel capitolo \ref{takamaka-chapter} abbiamo invece introdotto un nuovo framework che porta il nome di Takamaka, descritto nel dettaglio nel paper \cite{paper-takamaka:spoto}, scritto dal Prof. Nicola Fausto Spoto dell'Università di Verona. Lo sviluppo di questo progetto nasce dall'idea di creare un framework  che permetta di sfruttare le competenze e gli strumenti già esistenti del mondo Java al fine di costruire smart contract in modo semplice e confortevole. Takamaka rappresenta un framework Java per la programmazione di smart contract. Utilizza in particolare un sottoinsieme di Java ed è inoltre supportato dalla libreria \lstinline|takamaka.jar|. I metodi di supporto permessi fanno perte della libreria standard java e vengono chiamati white-listed. Al loro interno ci saranno tutti quei metodi che assicurano un risultato deterministico, quindi per esempio non saranno quindi ammessi i metodi per la concorrenza. Nel capitolo \ref{metodi-java-non-deterministici} abbiamo quindi ricercato quei metodi, all'interno delle librerie Java, che presentano comportamenti non deterministici. Sono stati esaminati alcuni metodi della classe \lstinline|java.lang.Object| quali il metodo \lstinline|hashCode()| e il metodo \lstinline|toString()|. Nel primo caso siamo di fronte ad un metodo che ci ritorna l'hash dell'oggetto su cui è applicato e basandoci sulla definizione data a questa funzione possiamo subito procedere con il negarne l'utilizzo su blockchain. L'hash ritornato da tale funzione non deve rimanere costante da un'esecuzione all'altra e tanto meno tra jvm differenti. Il risultato ritornato da un codice che ne fa uso sarà diverso ad ogni esecuzione. Il metodo \lstinline|toString()| funziona in modo simile, infatti ritorna una stringa composta dal nome della classe di cui l'oggetto è istanza, seguita dal carattere '@' e una rappresentazione esadecimale dell'hashcode di tale oggetto. Il problema qui sta proprio nell'ultima parte, la rappresentazione esadecimale dell'oggetto a cui ritorniamo alle conclusioni tratte per il metodo \lstinline|hashCode()|.
Abbiamo po analizzato le classi \lstinline|java.util.HashSet| e \lstinline|java.util.HashMap| entrambe queste classi non forniscono garanzia circa l'ordinamento degli oggetti al loro interno. Gli elementi al loro interno sono dispersi in vari bucket tramite apposite funzioni hash. Per tali motivi l'utilizzo di queste classi non è raccomandato soprattutto se l'ordinamento degli oggetti contenuti da queste strutture può in qualche modo influire sui risultati in output e quindi sullo stato globale. Una possibile problematica può insorgere nel caso venisse implementato un metodo su blockchain che ritorna un iteratore di un oggetto di una di queste classi. Il metodo \lstinline|iterator()| fa al caso, e dato che ritorna gli elementi con lo stesso ordine con cui gli elementi compaiono all'interno del \lstinline|Set| o della \lstinline|Map| in cui sono contenuti, e dato che tale ordine non è garantito rimanere costante, sarebbe buona norma vietare l'utilizzo all'interno di blockchain. La classe analizzata subito dopo è stata la classe \lstinline|java.util.Stream| che rappresenta un flusso di riferimenti ad oggetti su cui possono essere eseguite operazioni di aggregazione in modo parallelo o sequenziale. Già da questa definizione possiamo concludere che tutti quei metodi che permettono l'esecuzione parallela di operazioni su tali stream dovrebbero essere vietate. Ci siamo poi soffermati ad analizzare il metodo \lstinline|findAny()|, operazione terminale degli stream, che restituisce qualche elemento della stream il cui comportamento risulta esplicitamente non deterministico. Anche questo metodo viene appunto vietato ma, nel caso si necessitasse di un metodo con la medesima funzionalità, è consigliato l'utilizzo del metodo \lstinline|finfFirst()| il cui comportamento risulta invece deterministico. L'analisi del metodo \lstinline|forEach| porta alle stesse conclusioni dato che ache in questo caso la documentazione parla chiaro "\textit{Il comportamento di questa operazione è esplicitamente non deterministico}". Viene inoltre riportato che tale metodo, nelle esecuzioni su parallelStream, non garantisce il rispetto dell'ordine con cui gli elementi si presentavano inizialmente nello stream, questo per non compromettere i benefici introdotti dall'analisi parallela. Nonostante gli svariati test di applicazione del metodo \lstinline|forEach| a delle stream sequenziali abbiano riportato sempre gli stessi risultati, facendo credere che tale metodo si comporti in modo deterministico, la documentazione parla chiaro e se è indicato che tale operazione è esplicitamente non deterministica non significa che non si comporterà mai in modo non deterministico, ma bensì che tale metodo non è affatto obbligato a comportarsi in modo deterministico. Per questo motivo il non riuscire a trovare un esempio di funzionamento anomalo non può voler dire che tale metodo ritorni sempre i risultati aspettati. Possiamo quindi concludere che tale metodo non può essere incluso all'interno dei metodi white-listed di takamaka. Nel caso il programmatore necessitasse di un metodo che esegua delle operazioni su ogni elemento della stream preservando l'ordine iniziale dalla stream, può comunque utilizzare il metodo \lstinline|forEachOrdered| che a differenza del fratello \lstinline|forEach| risulta deterministico anche se applicato a stream parallele. L'analisi si è poi spostata sul metodo \lstinline|peek| che risulta molto simile a \lstinline|forEach| se non per il fatto che è un operazione intermedia e quindi ritorna una stream. Viene solitamente usata per il debug ma questo non ne esclude l'utilizzo su blockchain. Questa operazione soffre purtroppo delle stesse problematiche descritte per il metodo \lstinline|forEach| e dobbiamo perciò escluderlo dall'utilizzo su blockchain.

L'analisi prosegue con la classe \lstinline|java.util.Random| che sembrava inizialmente scartata a priori dato che porta della casualità all'interno della blockchain ma vedremo che non è così per tutti i suoi costruttori. Infatti il suo costruttore principale, \lstinline|Random()| crea un'istanza della classe \lstinline|Random| partendo comunque da un \lstinline|seed| che non sarà immesso dall'utente ma verrà recuperato dal sistema tramite il metodo \lstinline|System.nanoTime()|. Comprendiamo quindi il vero funzionamento della classe in analisi e intuiamo quindi che tale metodo ritorni risultati diversi su macchine diverse, dato che il valore del \lstinline|seed|, settato tramite la funzione \lstinline|System.nanoTime()|, restituirà risultati diversi su ogni macchina sulla quale verrà richiamato. Nel caso in cui questo valore \lstinline|seed| venga invece settato manualmente ci troveremo davanti ad un generatore pseudocasuale che, partendo dal valore imposto di \lstinline|seed|, calcola la medesima sequenza di valori su ogni JVM. L'unica restrizione è data dal fatto che tutte la macchine virtuali condividano la stessa funzione LCF. L'accettare la classe \lstinline|Random| se e solo se instanziata tramite il passaggio di un valore di \lstinline|seed|, da la possibilità al programmatore di a avere a disposizione un metodo che gli permette di creare un generatore di numeri pseudocasuali che in certe occasioni potrebbe essergli utile.

L'ultima analisi si sposta inevitabilmente con l'analisi della classe \lstinline|java.lang.System|, citata all'interno dell'analisi della classe \lstinline|Random|. Come abbiamo visto contiene il metodo \lstinline|nanoTime()| che ritorna un valore temporale di esecuzione della JVM misurato in nanosecondi. L'utilizzo di questo metodo all'interno della classe \lstinline|Random| è data dal fatto che il valore da lui restituito rappresenta un valore abbastanza casuale da scongiurare istanze simili. Anche per il metodo \lstinline|currentTimeMillis()| capiterà una sorte simile, infatti anch'esso fa riferimento a dei valori temporali che possono comunque discostarsi nelle varie esecuzioni tra JVM diverse. Questo metodo restituisce un \lstinline|long| che rappresenta il tempo corrente misurando i millisecondi intercorsi dalle ore 00:00:00 del 01/01/1970. Questo valore sarà chiaramente diverso per ogni JVM. Un ulteriore problematica è sorta dal fatto che il vietare l'utilizzo di tale metodi implica il negare l'utilizzo di tutti quei metodi di altre classi che ne fanno normalmente uso. Tra queste, nel caso di \lstinline|cueerntTimeMillis()| dovremmo procedere con il negare l\`Eesecuzione dei metodi presenti, per esempio, all'interno delle classi \lstinline|java.util.Date|, \lstinline|java.time.Clock| e \lstinline|java.util.Timer| che ne fanno uso. Questa considerazione è ovviamente estesa a tutti i metodi sopra descritti, e non utilizzabili nel contesto blockchain.