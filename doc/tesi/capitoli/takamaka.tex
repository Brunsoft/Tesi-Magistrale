% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%************************************************
\chapter{Takamaka}
\label{takamaka-chapter}
%************************************************
Questo capitolo è tratto dall'articolo \cite{paper-takamaka:spoto}, scritto dal docente Nicola Fausto Spoto, nel quale si definisce un framework per la programmazione in Java, di smart contract su blockchain. Tale framework sarà costituito da una routine limitata e da un set di classi che dovranno essere mantenute su blockchain per essere utilizzati dai metodi di contratto e per la misurazione del gas. Questo framework permette inoltre di sfruttare le competenze e gli strumenti già esistenti del mondo Java, al fine di  costruire smart contract in modo semplice e confortevole. 

\section{Un Framework Java per Smart Contract}
Takamaka\footnote{Takamaka è una valle nell'isola della Réunion Francese, dove una rete di cascate converge in un fiume. Questo è simile ai contratti intelligenti Takamaka, cioè a oggetti distinti che collaborano su uno spazio di archiviazione globale condiviso nella blockchain.} è un framework Java per la programmazione di smart contract. Più in particolare, questo framework, è un sottoinsieme di Java, supportato dalla sua libreria runtime \lstinline|takamaka.jar| che include le poche classi che descriveremo in seguito. È anche supportato da una selezione di metodi white-listed della libreria standard di Java. Questi sono metodi la cui esecuzione risulta deterministica. Per esempio, i metodi per la concorrenza non sono permessi, non saranno quindi white-listed in quanto potrebbero portare a comportamenti non deterministici. Il software Takamaka è scritto, verificato ed eseguito come segue:
\begin{description}
	\item[Sviluppo] 
		Le applicazioni Takamaka sono sviluppate come normali applicazioni Java, incluso \lstinline|takamaka.jar|. Non esiste un ambiente di sviluppo speciale per Takamaka. Infatti, è possibile utilizzare qualsiasi IDE o anche solo un compilatore a riga di comando. Il risultato, in ogni caso, sarà l'archivio \lstinline|app.jar| dell'applicazione in fase di sviluppo.
	\item[Verifica] 
		Le classi all'interno di \lstinline|app.jar| vengono verificate per fare in modo che facciano riferimento solo a metodi white-listed. Inoltre, questo passaggio viene verificato che le classi in memoria abbiano componenti di tipo consentito (Sezione 6).
	\item[Installazione]
		L'archivio \lstinline|app.jar| viene installato sulla blockchain, attivando una transazione che installa un jar (Sezione 3).
	\item[Strumentazione]
		Le classi all'interno di \lstinline|app.jar| vengono strumentate. In particolare, le classi di memoria subiscono una trasformazione a livello bytecode che consente ai loro oggetti di essere caricati lentamente in RAM durante l'esecuzione di una transazione e mantenerli aggiornati sulla blockchain, alla sua fine, se sono stati aggiornati (Sezione 6). Inoltre, nel codice viene iniettato un aspetto di misurazione del gas (Sezione 9).
	\item[Esecuzione] 
		Le classi definite in \lstinline|app.jar|, incluse le classi di contratto, vengono istanziate attraverso una transazione che esegue il loro costruttore (Sezione 5). Il risultante \textit{storage reference} può essere usato per richiamare i metodi del nuovo oggetto.
\end{description}
Quello che segue è un esempio di un contratto di crowdfunding scritto a Takamaka. Questo contratto permette a dei finanziatori di versare fondi da devolvere per una campagna. Una volta raggiunta la soglia di una certa campagna i fondi possono essere sbloccati. Tale implementazione consiste in due classi. Vediamo la prima, \lstinline|Founder.java|.
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Storage;
	
	public class Funder extends Storage {
		private final Contract who;
		private final int amount;
		
		public Funder(Contract who, int amount) {
			this.who = who;
			this.amount = amount;
		}
	}
\end{lstlisting}
%
Definisce il finanziatore di una campagna, cioè un contratto che riporta la quantità di denaro che un determinato \lstinline|Founder| intende devolvere per una certa campagna. Dato che questi oggetti devono essere persistenti in blockchain, la classe \lstinline|Founder| deve estendere \lstinline|takamaka.lang.Storage|. Vediamo ora la seconda classe, \lstinline|CrowdFunding.java|:
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Payable;
	import takamaka.lang.Storage;
	import takamaka.util.StorageList;
	
	public class CrowdFunding extends Contract {
		private final StorageList<Campaign> campaigns = new StorageList<>();  ■\label{line:storage_list}■
		
		public void newCampaign(Contract beneficiary, int goal) {
			campaigns.add(new Campaign(beneficiary, goal));
		}
		
		public @Payable @Entry void contribute(int amount, int campaignID) {  ■\label{line:payable}■
			campaigns.elementAt(campaignID).addFunder(payer(), amount);
		}
		
		public boolean checkGoalReached(int campaignID) {
			return campaigns.elementAt(campaignID).payIfGoalReached();
		}
		
		private class Campaign extends Storage {  ■\label{line:campaign_is_storage}■
			private final Contract beneficiary;
			private final int fundingGoal;
			private final StorageList<Funder> funders = new StorageList<>();
			private int amount;
		
			private Campaign(Contract beneficiary, int fundingGoal) {
				this.beneficiary = beneficiary;
				this.fundingGoal = fundingGoal;
			}
		
			private void addFunder(Contract who, int amount) {
				funders.add(new Funder(who, amount)); this.amount += amount;
			}
		
			private boolean payIfGoalReached() {
				if (amount >= fundingGoal) {
					pay(beneficiary, amount); ■\label{line:pay}■
					amount = 0;
					return true;
				}
				else
					return false;
			}
		}
	}
\end{lstlisting}
%
Rappresenta il contratto del coordinatore del crowdfunding, garantisce che i fondi dedicati ad una campagna non possano essere negati una volta raggiunto l'obiettivo. Consente di avviare una nuova campagna tramite \lstinline|new Campaign|, che mantiene il proprio astato all'interno dell'elenco di campagne avviate. Tale elenco utilizza la classe \lstinline|takamaka.util.StorageList|, che estende \lstinline|Storage|, e può quindi essere presente in blockchain. È possibile contribuire ad una certa campagna tramite \lstinline|contribute|. Viene data la possibilità di verificare se l'obiettivo della campagna è stato raggiunto tramite \lstinline|checkGoalReached|. La campagna è implementata tramite la classe interna \lstinline|Campaign|, in questo modo può fare riferimento al contratto esterno e consentendo di richiamare il metodo \lstinline|pay| del contratto (riga \ref{line:pay}), che trasferisce una data somma di denaro ad un determinato beneficiario. Questo metodo della classe \lstinline|Contract| è \lstinline|final| e di conseguenza non può essere ridefinito, evitando così qualsiasi rischio di reentrancy. È interessante notare che \lstinline|Campaign| estende \lstinline|Storage| (riga \ref{line:campaign_is_storage}) perchè le sue istanze sono contenute all'interno dell'elenco \lstinline|campaigns|, (riga \ref{line:storage_list}) e di conseguenza deve essere persistente nella blockchain.
Alla riga \ref{line:payable} sono presenti le annotazioni \lstinline|@Payable @Entry|. \lstinline|@Entry| indica che si tratta di un punto d'accesso inter-contrattuale e limita il metodo ad appartenere ad una classe che estende \lstinline|takamaka.lang.Contract|. All'interno dei metodi \lstinline|@Entry| è possibile chiamare il metodi \lstinline|payer|, che restituisce il contratto chiamato. In generale, il programmatore utilizzerà \lstinline|@Entry| quando desidera identificare il contratto del metodo richiamato o desidera ricevere denaro da tale contratto. L'annotazione \lstinline|@Payable| può essere aggiunta solamente ad un costruttore o metodo \lstinline|@Entry|. Ciò significa che quest'ultimo riceverà denaro dal contratto \lstinline|payer|. Takamaka trasferirà automaticamente la somma specificata da \lstinline|payer| al contratto di destinazione.

\section{Salvare i file Jar sulla Blockchain}
Takamaka permette di conservare i jars sulla blockchain. Ci sono transazioni che memorizzano jar con riferimenti alle sue dipendenze, se presenti. Il meccanismo ricorda quello che viene fatto attualmente in Ivy o Ant: per memorizzare un jar $j$, viene creata una transazione $t$, che aggiunge $j$ alla blockchain, assieme ai riferimenti ad altre transazioni in cui le sue dipendenze, $d_1, \dots, d_n$, se presenti, sono state precedentemente memorizzate sulla blockchain. Il riferimento a $t$ può quindi essere utilizzato per memorizzare altri jars che dipendono da $j$. Le dipendenze ricorsive tra jars non sono consentite. Le eventuali dipendenze possono essere risolte in modo transitivo o non transitivo. Questo è legato alla costruzione del classpath per l'installazione dello smart contract (Sezione 5). Per memorizzare $j$ sulla blockchain, la transazione memorizzerà i seguenti dati:
%
\[\langle j, *d_1, t_1, \dots, *d_n, t_n \rangle\]
%
dove $*d_1$ è il riferimento al jar $i$-esimo da cui dipende $j$, $t_1$ è invece un booleano che afferma se la dipendenza è transitiva o meno. 

\section{Storage}
Uno smart contract ha un proprio \textit{stato}, costituito dai valori dei suoi campi e dagli oggetti raggiungibili da essi, in modo ricorsivo. Tale stato è persistente sulla blockchain, dopo la creazione di un contratto o dopo l'esecuzione di una transazione contrattuale. Per efficienza vengono mantenuti solo gli aggiornamenti dello stato, anziché lo stato completo. Si noti che contratti distinti potrebbero condividere parte del loro stato, quindi una transazione su di un contratto potrebbe andare a modificare oggetti visibili ad un altro contratto, questo è uno standard per Java. Può essere usato come forma di comunicazione tra con tratti sulla blockchain. Gli stati di tutti i contratti installati su blockchain formano una struttura ad heap, persistente, chiamata \textit{storage}. I riferimenti agli oggetti di archiviazione sono chiamati \textit{storage references} e hanno la forma:
%
\[\langle block\_number, \mathit{transaction \_number}, \mathit{progressive} \rangle \]
%
questo significa che farà riferimento all'oggetto $progressive$-esimo istanziato durante l'esecuzione della transazione $transaction\_number$-esima, all'interno del blocco $block\_number$-esimo.

Quando viene eseguita una transazione di contratto, lo stato del contratto viene caricaro in RAM, con i campi che contengono i riferimenti di memoria che riflettono i riferimenti di archiviazione dello stato persistente. Quindi una transazione viene eseguita all'interno di una standard \textit{Java Virtual Machine}, in RAM. Alla fine dell'esecuzione, tutti gli aggiornamenti dell'heap allo stato del contratto vengono resi persistenti nello storage. Questo avviene in modo automatico ed in maniera trasparente per il programmatore. Ciò significa che gli oggetti Java, in RAM, che possono essere persistenti sullo storage, come tutte le classi che implementano un contratto, devono avere la capacità di identificare gli eventuali aggiornamenti ai loro campi, in modo efficiente. Per questo motivo, Takamaka richiede che gli oggetti storage estendano \lstinline|takamaka.lang.Storage|: solo gli oggetti che estendono tale classe possono essere persistenti nello storage. Tutti questi aggiornamenti saranno memorizzati nello storage come \textit{storage updates}. Quest'ultimi saranno rappresentati da triple del tipo $\langle ref, sig, new\_value \rangle$, il che significa che il campo con firma $sig$ dell'oggetto il cui riferimento in memoria $ref$ è stato aggiornato al $new\_value$ indicato. Gli aggiornamenti possono essere compattati così da ridurne le dimensioni di archiviazione.

Supponiamo che i client espongano la blockchain come oggetto accessibile tramite \lstinline|Blockchain.getInstance()|, con i seguenti metodi:

\vspace{1ex}
\noindent
\lstinline|getCurrentTransaction()|:
	restituisce la transazione corrente in esecuzione.
	
\vspace{1ex}
\noindent
\lstinline|getTopmostBlock()|:
	produce il blocco più in alto del blockchaind.

\vspace{1ex}
\noindent
\lstinline|deserialize(r)|:
	produce un oggetto $o$ che è la deserializzazione dalla blockchain del riferimento di memoria $r$.
	
\vspace{1ex}
\noindent
\lstinline|deserializeLastUpdateFor(r, "C.f:D")|:
	restituisce l'oggetto $o'$ tenuto all'interno del campo di riferimento \lstinline|Cf: D| (\textit{i.e.} il campo \lstinline|f|, definito nella classe \lstinline|C| e avente tipo di riferimento \lstinline|D|) di un oggetto container il cui riferimento nello storage è $r$.
	
\section{Creazione di uno smart contract}
L'istanziazione una classe $C$, possibilmente implementando uno smart contract e quindi estendendo \lstinline|takamaka.lang.Contract| viene attivata da un utente della blockchain e consiste nella creazione di un'istanza di $C$. Il costruttore di $C$ viene chiamato con alcuni parametri. Lo stato risultante del contratto risulterà persistente in blockchain, come una set di aggiornamenti di storage. Questo set contiene gli aggiornamenti che portano all'ultima istanza di $C$, ma c'è la possibilità che contenga aggiornamenti di altri oggetti di storage utilizzati nell'implementazione di $C$. 

Per istanziare $C$, è necessario specificare $*j$, il riferimento al jar fornendo così il classpath per l'esecuzione del costruttore $C$ ed un valore booleano $t$ che specifica se le dipendenze del jar devono essere incluse in modo transitivo. Inoltre deve essere specificata una firma $sig = C(\dots)$ del costruttore, ed infine i parametri $pars$ che tale costruttore deve specificare, se ce ne sono. Quindi un client riceve la richiesta di creare un nuovo contratto come: $\langle *j, t, sig, pars \rangle$. I parametri $pars$ possono essere valori primitivi, dati dalla serializzazione Java, oppure riferimenti ad oggetti nello storage. L'esecuzione del costruttore comporterà degli aggiornamenti allo stato, compresi quelli per inizializzare il nuovo oggetto. Tuttavia potrebbero essere modificati anche altri stored object, se raggiungibili dai parametri passati al costruttore. In conclusione, la transazione aggiunta alla blockchain consiste nella tupla $\langle *j, t, sig, pars, result, updates \rangle$, dove $result$ è la referenza allo storage al nuovo oggetto $o$ della classe $C$ e $update$ colleziona tutti gli aggiornamenti allo storage, compresi quelli che inizializzano i campi dell'oggetto $o$. Nel caso particolare in cui l'esecuzione del costruttore termina con un'eccezione, $result$ conterrà la descrizione di tale eccezione e $update$ non contiene modifice ad $o$, se è irraggiungibile.

\section{Classi storage e la loro strumentazione}
Le classi storage estendono \lstinline|takamaka.lang.Storage|. Poiché solo tali classi possono essere mantenute in modo permanente in blockchain, ne consegue che i loro campi devono essere primitivi o, in modo ricorsivo, avere una storage class. La classe \lstinline|takamaka.lang.Storage| implementa dei meccanismi base per tenere traccia del riferimento nello storage dell'istanza. Ciò significa che un oggetto nello storage $o$, quando sarà in RAM, potrebbe essere presente l'oggetto deserializzato $o'$, già presente in blockchain, in quel caso il suo campo \lstinline|onStorage| è settato a true, e i suoi campi \lstinline|blockNumber|, \lstinline|transactioNumber| e \lstinline|progressive| sono i riferimenti nello storage di $o'$. Ma $o$ potrebbe non essere ancora presente in blockchain e quindi rappresentare un nuovo storage object, istanziato durante l'esecuzione di una transazione, che potrebbe essere successivamente conservato su blockchain, al termine della transazione. In questo caso il campo \lstinline|inStorage| varrà false e i campi \lstinline|blockNumber|, \lstinline|transactionNumber| e \lstinline|progressive| conterranno i riferimenti nello storage assegnati ad $o'$ nel caso di mantenimento in blockchain. Per rappresentare queste due alternative, \lstinline|takamaka.lang.Storage| ha due costruttori.
%
\begin{lstlisting}
	// constructor used by the programmer to build objects not yet in storage
	protected C() {
		this.inStorage = false;
		this.storageReference = new StorageReference(
			blockchain.getTopmostBlock().getNumber(),
			blockchain.getCurrentTransaction().getNumber(),
			nextProgressive++ );
	}
	...
	// constructor used by Takamaka to build objects deserialized from storage
	protected C( StorageReference storageReference ) {
		this.inStorage = true;
		this.storageReference = storageReference;
	}
	// vedi l'intera classe Storage sul paper Takamaka ■\cite{paper-takamaka:spoto}■
\end{lstlisting}
%
Takamaka al termine della transazione, chiama $o$.\lstinline|extractUpdates(updates)|, su tutti gli oggetti $o$ raggiungibili dallo stato del contratto o dai parametri di transazione. Raccoglie quindi in \lstinline|update| gli aggiornamenti di $o$ di cui si dovrà tener traccia nello storage e restituisce la storage reference di $o$ nella blockchain. La classe \lstinline|takamaka.lang.Storage|, non definisce i campi che appartengono allo stato di un oggetto nello storage: saranno le sottoclassi a ridefinire \lstinline|extractUpdate| per creare gli update. I programmatori scriveranno le classi di storage come normali classi Java estendendo \lstinline|takamaka.lang.Storage|. Il codice di tali classi subirà poi una trasformazione automatica prima di essere eseguito, per consentire:
\begin{enumerate}
	\item la generazione degli update alla fine di ogni transazione: gli oggetti nello storage hanno campi strumentati che consentono a Takamaka di identificare le parti del loro stato che ha subito modifiche.
	\item la deserializzazione, su richiesta, di storage object a cui si accede durante una transazione. Infatti, è teoricamente possibile caricare in RAM l'intero stato di un contratto, in modo ricorsivo, prima di una transazione. Ma tutto ciò sarebbe poco pratico dato che tale stato potrebbe essere molto grande e, inoltre, la deserializzare oggetti storage in RAM è un'operazione lenta poiché richiede l'accesso alla blockchain.
\end{enumerate}
Per esemplificare la trasformazione, supponiamo che un programmatore scriva la seguente classe:
%
\begin{lstlisting}[numbers=none,frame=none]
	public class C extends Storage {
		private D f1;
		private int f2;
		public C(pars) {
			// implicit call to super() here
			body
		}
		methods
	}
\end{lstlisting}
%
Tale classe viene compilata in java bytecode. Prima della sua esecuzione, viene automaticamente trasformato nel bytecode corrispondente al seguente sorgente:
%
\begin{lstlisting}
	public class C extends Storage {
		private D f1;
		private D oldF1;
		private boolean f1AlreadyLoaded;
		private int f2;
		private int oldF2;
	
		public C(pars) {
			// implicit call to super() here
			instrumented body     ■\label{line:instrumented1}■
		}
	
		// constructor added for deserialization from storage
		public C(StorageReference storageReference, int _f2) { ■\label{line:constructor_deserialization_C}■
			super(storageReference);
			f2 = oldF2 = _f2;
		}
		
		// method that replaces f1 read operations
		private D getF1() {
			ensureLoadedF1();     ■\label{line:ensure1}■
			return f1;
		}
		
		// method that replaces f1 write operations
		private void putF1(D _f1) {
			ensureLoadedF1();     ■\label{line:ensure2}■
			f1 = _f1;
		}
		
		private void ensureLoadedF1() {
			if (inStorage && !f1AlreadyLoaded) {
				oldF1 = (D) blockchain.deserializeLastUpdateFor(
					storageReference, "C.f1:D");
				f1AlreadyLoaded = true;
			}
		}
		
		public StorageReference extractUpdates(Updates updates) {
			StorageReference _this = super.extractUpdates(updates);
			if (!inStorage || f1 != oldF1)
				updates.add(<_this, "C.f1:D", recursiveExtract(f1, updates)>); ■\label{line:recursion1}■
			recursiveExtract(oldF1, updates); ■\label{line:recursion2}■
			if (!inStorage || f2 != oldF2)
				updates.add(<_this, "C.f2:int", f2>);
		
			return _this;
		}
		
		instrumented methods      ■\label{line:instrumented2}■
	}
\end{lstlisting}
%
Quando uno storage object viene deserializzato dallo storage, i suoi campi primitivi vengono inizializzati dal costruttore sintetico aggiunto alla riga \ref{line:constructor_deserialization_C}. I campi di riferimento, invece, restano \lstinline|null| dopo la deserializzazione e saranno settati più tardi, se richiamati (righe \ref{line:ensure1} e \ref{line:ensure2}). Di conseguenza, gli accessi ai campi di riferimento, come \lstinline|f1|, sono stati sostituiti da chiamate a metodi accessori, nel nostro caso \lstinline|getF1| e \lstinline|putF1|, assicurandosi che tale campo sia già stato caricato in blockchain. Questo comporta la sostituzione, alle righe \ref{line:instrumented1} e \ref{line:instrumented2}, del bytecode \lstinline|getfield C.f1: D| con \lstinline|invokevirtual C.getF1(): D|, e \lstinline|putfield C.f1: D| con \lstinline|invokevirtual C.putF1(): void|. Dopo la trasformazione, gli unici accessi a \lstinline|f1| saranno effettuati all'interno di \lstinline|getF1| e \lstinline|putF1|. 

Il metodo sintetico \lstinline|extractUpdates| raccoglie i campi di \lstinline|this| che sono stati aggiornati dopo la sua creazione, prendendo il nuovo valore. Se \lstinline|this| è stato creato durante la transazione, allora non era \lstinline|inStorage| e tutti i valori dei suoi campi devono essere diventare persistenti. In caso contrario, solo i campi che hanno subito una modifica devono essere mantenuti. Il metodo \lstinline|extractUpdates| ricorre sia al valore corrente dei campi referenziati (riga \ref{line:recursion1}) sia al loro valore originale sulla blockchain (riga \ref{line:recursion2}). Questa seconda ricorsione risulta importante poiché il precedente valore potrebbe essere raggiunto da oggetti diventati irraggiungibili dal contratto una volta eseguita la transazione, ma che sono ancora recuperabili da altri contratti sullo storage. I loro aggiornamenti devono essere mantenuti o altrimenti questi contratti non vedranno queste modifiche.

I campi dichiarati come \lstinline|transient| hanno avuto un trattamento speciale affinché non prendano parte allo stato persistente dell'oggetto. Quindi, il costruttore sintetico per la deserializzazione non riceve il loro valore e il metodo \lstinline|extrectUpdates| li salta. Non esiste una versione \lstinline|old| per loro, dal momento che non sarebbe utilizzata. Il valore dei campi \lstinline|transient| viene infatti perso alla fine della transazione. All'avvio di un'altra transazione, tali campi sembreranno reinpostati sul loro valore predefinito.

L'introduzione di nuovi campi, costruttori e metodi per storage class potrebbe portare a conflitti di nome se, ad esempio, esistesse già un campo \lstinline|oldF1|. Per evitare che questo accada, la strumentazione utilizza nomi affettivamente illegali come identificatori in Java, ma legali se usati come identificatori in Java bytecode.

La trasformazione può essere estesa alle classi storge \lstinline|C| che estendono la superclasse \lstinline|S| distinta da \lstinline|takamaka.lang.Storage|. Le classi storage possono solo estendere un'altra classe storage \lstinline|S| che dovrà essere una storage class, quindi estendere \lstinline|takamaka.lang.Storage|. L'unica differenza è che il costruttore per la deserializzazione (riga \ref{line:constructor_deserialization_C}), oltre a \lstinline|_f2|, riceverà anche gli altri campi primitivi \lstinline|_fs| definiti nelle superclassi. Tale \lstinline|_fs| sarà passato al costruttore della superclasse per la deserializzazione:
%
\begin{lstlisting}[numbers=none,frame=none]
	public C(StorageReference storageRefernce, _fs, int _f2) {
		super(storageReference, _fs);
		f2 = oldF2 = _f2;
	}
\end{lstlisting}
%