% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%************************************************
\chapter{Takamaka} \label{takamaka-chapter}
%************************************************
Questo capitolo è tratto dall'articolo \cite{paper-takamaka:spoto}, scritto dal docente Nicola Fausto Spoto, nel quale si definisce un framework per la programmazione in Java, di smart contract su blockchain. Tale framework sarà costituito da una routine limitata e da un set di classi che dovranno essere mantenute su blockchain per essere utilizzati dai metodi di contratto e per la misurazione del gas. Questo framework permette inoltre di sfruttare le competenze e gli strumenti già esistenti del mondo Java, al fine di costruire smart contract in modo semplice e confortevole. 

\section{Un Framework Java per Smart Contract} \label{takamaka:un-framework-java-per-smart-contract}

Takamaka\footnote{Takamaka è una valle nell'isola della Réunion Francese, dove una rete di cascate converge in un fiume. Questo è simile ai contratti intelligenti Takamaka, cioè a oggetti distinti che collaborano su uno spazio di archiviazione globale condiviso nella blockchain.} è un framework Java per la programmazione di smart contract. Più in particolare, questo framework, è un sottoinsieme di Java, supportato dalla sua libreria runtime \lstinline|takamaka.jar| che include le poche classi che descriveremo in seguito. È anche supportato da una selezione di metodi white-listed della libreria standard di Java. Questi sono metodi la cui esecuzione risulta deterministica. Per esempio, i metodi per la concorrenza non sono permessi, non saranno quindi white-listed, in quanto potrebbero portare a comportamenti non deterministici. Il software Takamaka è scritto, verificato ed eseguito come segue:
\begin{description}
	\item[Sviluppo] 
		Le applicazioni Takamaka sono sviluppate come normali applicazioni Java, incluso \lstinline|takamaka.jar|. Non esiste un ambiente di sviluppo speciale per Takamaka. Infatti, è possibile utilizzare qualsiasi IDE o anche solo un compilatore a riga di comando. Il risultato, in ogni caso, sarà l'archivio \lstinline|app.jar| dell'applicazione in fase di sviluppo.
	\item[Verifica] 
		Le classi all'interno di \lstinline|app.jar| vengono verificate per fare in modo che facciano riferimento solo a metodi white-listed. Inoltre, questo passaggio viene verificato che le classi in memoria abbiano componenti di tipo consentito (Sezione \ref{takamaka:classi-storage-e-la-loro-strumentazione}).
	\item[Installazione]
		L'archivio \lstinline|app.jar| viene installato sulla blockchain, attivando una transazione che installa un jar (Sezione \ref{takamaka:salvare-i-file-jar-sulla-blockchain}).
	\item[Strumentazione]
		Le classi all'interno di \lstinline|app.jar| vengono strumentate. In particolare, le classi di memoria subiscono una trasformazione a livello bytecode che consente ai loro oggetti di essere caricati in RAM durante l'esecuzione di una transazione e mantenerli aggiornati sulla blockchain, alla sua fine, se sono stati aggiornati (Sezione \ref{takamaka:classi-storage-e-la-loro-strumentazione}). Inoltre, nel codice viene iniettato un aspetto di misurazione del gas (Sezione \ref{takamaka:gas}).
	\item[Esecuzione] 
		Le classi definite in \lstinline|app.jar|, incluse le classi di contratto, vengono istanziate attraverso una transazione che esegue il loro costruttore (Sezione \ref{takamaka:creazione-du-uno-smart-contract}). Il risultante \textit{storage reference} può essere usato per richiamare i metodi del nuovo oggetto.
\end{description}
Quello che segue è un esempio di un contratto di crowdfunding scritto a Takamaka. Questo contratto permette a dei finanziatori di versare fondi da devolvere per una campagna. Una volta raggiunta la soglia di una certa campagna i fondi versati possono essere sbloccati. Tale implementazione consiste in due classi. Vediamo la prima, \lstinline|Founder.java|.
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Storage;
	
	public class Funder extends Storage {
		private final Contract who;
		private final int amount;
		
		public Funder(Contract who, int amount) {
			this.who = who;
			this.amount = amount;
		}
	}
\end{lstlisting}
%
Definisce il finanziatore di una campagna, cioè un contratto che riporta la quantità di denaro che un determinato \lstinline|Founder| intende devolvere per una certa campagna. Dato che questi oggetti devono essere persistenti in blockchain, la classe \lstinline|Founder| deve estendere \lstinline|takamaka.lang.Storage|. Vediamo ora la seconda classe, \lstinline|CrowdFunding.java|:
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Payable;
	import takamaka.lang.Storage;
	import takamaka.util.StorageList;
	
	public class CrowdFunding extends Contract {
		private final StorageList<Campaign> campaigns = new StorageList<>();  ■\label{line:storage_list}■
		
		public void newCampaign(Contract beneficiary, int goal) {
			campaigns.add(new Campaign(beneficiary, goal));
		}
		
		public @Payable @Entry void contribute(int amount, int campaignID) {  ■\label{line:payable}■
			campaigns.elementAt(campaignID).addFunder(payer(), amount);
		}
		
		public boolean checkGoalReached(int campaignID) {
			return campaigns.elementAt(campaignID).payIfGoalReached();
		}
		
		private class Campaign extends Storage {  ■\label{line:campaign_is_storage}■
			private final Contract beneficiary;
			private final int fundingGoal;
			private final StorageList<Funder> funders = new StorageList<>();
			private int amount;
		
			private Campaign(Contract beneficiary, int fundingGoal) {
				this.beneficiary = beneficiary;
				this.fundingGoal = fundingGoal;
			}
		
			private void addFunder(Contract who, int amount) {
				funders.add(new Funder(who, amount)); this.amount += amount;
			}
		
			private boolean payIfGoalReached() {
				if (amount >= fundingGoal) {
					pay(beneficiary, amount); ■\label{line:pay}■
					amount = 0;
					return true;
				}
				else
					return false;
			}
		}
	}
\end{lstlisting}
%
Rappresenta il contratto del coordinatore del crowdfunding, garantisce che i fondi dedicati ad una campagna non possano essere negati una volta raggiunto l'obiettivo. Consente di avviare una nuova campagna tramite \lstinline|new Campaign|, che mantiene il proprio stato all'interno dell'elenco di campagne avviate. Tale elenco utilizza la classe \lstinline|takamaka.util.StorageList|, che estende \lstinline|Storage|, e può quindi essere presente in blockchain. È possibile contribuire ad una certa campagna tramite \lstinline|contribute|. Viene data la possibilità di verificare se l'obiettivo della campagna è stato raggiunto tramite \lstinline|checkGoalReached|. La campagna è implementata tramite la classe interna \lstinline|Campaign|, in questo modo può fare riferimento al contratto esterno e consentendo di richiamare il metodo \lstinline|pay| del contratto (riga \ref{line:pay}), che trasferisce una data somma di denaro ad un determinato beneficiario. Questo metodo della classe \lstinline|Contract| è \lstinline|final| e di conseguenza non può essere ridefinito, evitando così qualsiasi rischio di reentrancy. È interessante notare che \lstinline|Campaign| estende \lstinline|Storage| (riga \ref{line:campaign_is_storage}) perché le sue istanze sono contenute all'interno dell'elenco \lstinline|campaigns|, (riga \ref{line:storage_list}) e di conseguenza deve essere persistente nella blockchain.
Alla riga \ref{line:payable} sono presenti le annotazioni \lstinline|@Payable @Entry|. \lstinline|@Entry| indica che si tratta di un punto d'accesso inter-contrattuale e limita il metodo ad appartenere ad una classe che estende \lstinline|takamaka.lang.Contract|. All'interno dei metodi \lstinline|@Entry| è possibile chiamare il metodi \lstinline|payer|, che restituisce il contratto chiamato. In generale, il programmatore utilizzerà \lstinline|@Entry| quando desidera identificare il contratto del metodo richiamato o desidera ricevere denaro da tale contratto. L'annotazione \lstinline|@Payable| può essere aggiunta solamente ad un costruttore o metodo \lstinline|@Entry|. Ciò significa che quest'ultimo riceverà denaro dal contratto \lstinline|payer|. Takamaka trasferirà automaticamente la somma specificata da \lstinline|payer| al contratto di destinazione.

\section{Salvare i file Jar sulla Blockchain} \label{takamaka:salvare-i-file-jar-sulla-blockchain}
Takamaka permette di conservare i jars sulla blockchain. Ci sono transazioni che memorizzano jar con riferimenti alle sue dipendenze, se presenti. Il meccanismo ricorda quello che viene fatto attualmente in Ivy o Ant: per memorizzare un jar $j$, viene creata una transazione $t$, che aggiunge $j$ alla blockchain, assieme ai riferimenti ad altre transazioni in cui le sue dipendenze, $d_1, \dots, d_n$, se presenti, sono state precedentemente memorizzate sulla blockchain. Il riferimento a $t$ può quindi essere utilizzato per memorizzare altri jars che dipendono da $j$. Le dipendenze ricorsive tra jars non sono consentite. Le eventuali dipendenze possono essere risolte in modo transitivo o non transitivo. Questo è legato alla costruzione del classpath per l'installazione dello smart contract (Sezione \ref{takamaka:creazione-du-uno-smart-contract}). Per memorizzare $j$ sulla blockchain, la transazione memorizzerà i seguenti dati:
%
\[\langle j, *d_1, t_1, \dots, *d_n, t_n \rangle\]
%
dove $*d_1$ è il riferimento al jar $i$-esimo da cui dipende $j$, $t_1$ è invece un booleano che afferma se la dipendenza è transitiva o meno. 

\section{Storage} \label{takamaka:storage}
Uno smart contract ha un proprio \textit{stato}, costituito dai valori dei suoi campi e dagli oggetti raggiungibili da essi, in modo ricorsivo. Tale stato è persistente sulla blockchain, dopo la creazione di un contratto o dopo l'esecuzione di una transazione contrattuale. Per efficienza vengono mantenuti solo gli aggiornamenti dello stato, anziché lo stato completo. Si noti che contratti distinti potrebbero condividere parte del loro stato, quindi una transazione su di un contratto potrebbe andare a modificare oggetti visibili ad un altro contratto, questo è uno standard per Java. Può essere usato come forma di comunicazione tra contratti sulla blockchain. Gli stati di tutti i contratti installati su blockchain formano una struttura ad heap, persistente, chiamata \textit{storage}. I riferimenti agli oggetti di archiviazione sono chiamati \textit{storage references} e hanno la forma:
%
\[\langle block\_number, \mathit{transaction \_number}, \mathit{progressive} \rangle \]
%
questo significa che farà riferimento all'oggetto $progressive$-esimo istanziato durante l'esecuzione della transazione $transaction\_number$-esima, all'interno del blocco $block\_number$-esimo.

Quando viene eseguita una transazione di contratto, lo stato del contratto viene caricato in RAM, con i campi che contengono i riferimenti di memoria che riflettono i riferimenti di archiviazione dello stato persistente. Quindi una transazione viene eseguita all'interno di una standard \textit{Java Virtual Machine}, in RAM. Alla fine dell'esecuzione, tutti gli aggiornamenti dell'heap allo stato del contratto vengono resi persistenti nello storage. Questo avviene in modo automatico ed in maniera trasparente per il programmatore. Ciò significa che gli oggetti Java, in RAM, che possono essere persistenti sullo storage, come tutte le classi che implementano un contratto, devono avere la capacità di identificare gli eventuali aggiornamenti ai loro campi, in modo efficiente. Per questo motivo, Takamaka richiede che gli oggetti storage estendano \lstinline|takamaka.lang.Storage|: solo gli oggetti che estendono tale classe possono essere persistenti nello storage. Tutti questi aggiornamenti saranno memorizzati nello storage come \textit{storage updates}. Quest'ultimi saranno rappresentati da triple del tipo $\langle ref, sig, new\_value \rangle$, il che significa che il campo con firma $sig$ dell'oggetto il cui riferimento in memoria $ref$ è stato aggiornato al $new\_value$ indicato. Gli aggiornamenti possono essere compattati così da ridurne le dimensioni di archiviazione.
Supponiamo che i client espongano la blockchain come oggetto accessibile tramite \lstinline|Blockchain.getInstance()|, con i seguenti metodi:

%
\begin{table}[h]
	\centering
	\begin{tabular}{|c|p{6cm}|}
		\hline
		\lstinline|getCurrentTransaction()| & restituisce la transazione corrente in esecuzione.\\ \hline
		\lstinline|getTopmostBlock()| & produce il blocco più in alto sulla blockchain.\\ \hline
		\lstinline|deserialize(r)| & produce un oggetto $o$ che è la deserializzazione dalla blockchain del riferimento di memoria $r$.\\ \hline
		\lstinline|deserializeLastUpdateFor(r, "C.f:D")| & restituisce l'oggetto $o'$ tenuto all'interno del campo di riferimento \lstinline|Cf: D| (\textit{i.e.} il campo \lstinline|f|, definito nella classe \lstinline|C| e avente tipo di riferimento \lstinline|D|) di un oggetto container il cui riferimento nello storage è $r$.\\ \hline
	\end{tabular}
	\caption{Metodi messi a disposizione dall'oggetto Blockchain.}
	\label{tab:metodi-oggetto-blockchain}
\end{table}
%

\section{Creazione di uno smart contract} \label{takamaka:creazione-du-uno-smart-contract}
L'istanziazione una classe $C$, possibilmente implementando uno smart contract e quindi estendendo \lstinline|takamaka.lang.Contract|, viene attivata da un utente della blockchain e consiste nella creazione di un'istanza di $C$. Il costruttore di $C$ viene chiamato con alcuni parametri. Lo stato risultante del contratto risulterà persistente in blockchain, come una set di aggiornamenti di storage. Questo set contiene gli aggiornamenti che portano all'ultima istanza di $C$, ma c'è la possibilità che contenga aggiornamenti di altri oggetti di storage utilizzati nell'implementazione di $C$. 

Per istanziare $C$, è necessario specificare $*j$, il riferimento al jar fornendo così il classpath per l'esecuzione del costruttore $C$ ed un valore booleano $t$ che specifica se le dipendenze del jar devono essere incluse in modo transitivo. Inoltre deve essere specificata una firma $sig = C(\dots)$ del costruttore, ed infine i parametri $pars$ che tale costruttore deve specificare, se ce ne sono. Quindi un client riceve la richiesta di creare un nuovo contratto come: $\langle *j, t, sig, pars \rangle$. I parametri $pars$ possono essere valori primitivi, dati dalla serializzazione Java, oppure riferimenti ad oggetti nello storage. L'esecuzione del costruttore comporterà degli aggiornamenti allo stato, compresi quelli per inizializzare il nuovo oggetto. Tuttavia potrebbero essere modificati anche altri stored object, se raggiungibili dai parametri passati al costruttore. In conclusione, la transazione aggiunta alla blockchain consiste nella tupla $\langle *j, t, sig, pars, result, updates \rangle$, dove $result$ è la referenza allo storage al nuovo oggetto $o$ della classe $C$ e $update$ colleziona tutti gli aggiornamenti allo storage, compresi quelli che inizializzano i campi dell'oggetto $o$. Nel caso particolare in cui l'esecuzione del costruttore termina con un'eccezione, $result$ conterrà la descrizione di tale eccezione e $update$ non contiene modifiche ad $o$, se è irraggiungibile.

\section{Classi storage e la loro strumentazione} \label{takamaka:classi-storage-e-la-loro-strumentazione}
Le classi storage estendono \lstinline|takamaka.lang.Storage|. Poiché solo tali classi possono essere mantenute in modo permanente in blockchain, ne consegue che i loro campi devono essere primitivi o, in modo ricorsivo, avere una storage class. La classe \lstinline|takamaka.lang.Storage| implementa dei meccanismi base per tenere traccia del riferimento nello storage dell'istanza. Ciò significa che un oggetto nello storage $o$, quando sarà in RAM, potrebbe essere presente l'oggetto deserializzato $o'$, già presente in blockchain, in quel caso il suo campo \lstinline|onStorage| è settato a true, e i suoi campi \lstinline|blockNumber|, \lstinline|transactioNumber| e \lstinline|progressive| sono i riferimenti nello storage di $o'$. Ma $o$ potrebbe non essere ancora presente in blockchain e quindi rappresentare un nuovo storage object, istanziato durante l'esecuzione di una transazione, che potrebbe essere successivamente conservato su blockchain, al termine della transazione. In questo caso il campo \lstinline|inStorage| varrà false e i campi \lstinline|blockNumber|, \lstinline|transactionNumber| e \lstinline|progressive| conterranno i riferimenti nello storage assegnati ad $o'$ nel caso di mantenimento in blockchain. Per rappresentare queste due alternative, \lstinline|takamaka.lang.Storage| ha due costruttori.
%
\begin{lstlisting}
	// constructor used by the programmer to build objects not yet in storage
	protected C() {
		this.inStorage = false;
		this.storageReference = new StorageReference(
			blockchain.getTopmostBlock().getNumber(),
			blockchain.getCurrentTransaction().getNumber(),
			nextProgressive++ );
	}
	...
	// constructor used by Takamaka to build objects deserialized from storage
	protected C( StorageReference storageReference ) {
		this.inStorage = true;
		this.storageReference = storageReference;
	}
	// vedi l'intera classe Storage sul paper Takamaka ■\cite{paper-takamaka:spoto}■
\end{lstlisting}
%
Takamaka al termine della transazione, chiama $o$.\lstinline|extractUpdates(updates)|, su tutti gli oggetti $o$ raggiungibili dallo stato del contratto o dai parametri di transazione. Raccoglie quindi in \lstinline|updates| gli aggiornamenti di $o$ di cui si dovrà tener traccia nello storage e restituisce la storage reference di $o$ nella blockchain. La classe \lstinline|takamaka.lang.Storage|, non definisce i campi che appartengono allo stato di un oggetto nello storage: saranno le sottoclassi a ridefinire \lstinline|extractUpdate| per creare gli updates. I programmatori scriveranno le classi di storage come normali classi Java estendendo \lstinline|takamaka.lang.Storage|. Il codice di tali classi subirà poi una trasformazione automatica prima di essere eseguito, per consentire:
\begin{enumerate}
	\item la generazione degli update alla fine di ogni transazione: gli oggetti nello storage hanno campi strumentati che consentono a Takamaka di identificare le parti del loro stato che ha subito modifiche.
	\item la deserializzazione, su richiesta, di storage object a cui si accede durante una transazione. Infatti, è teoricamente possibile caricare in RAM l'intero stato di un contratto, in modo ricorsivo, prima di una transazione. Ma tutto ciò sarebbe poco pratico dato che tale stato potrebbe essere molto grande e, inoltre, la deserializzare oggetti storage in RAM è un'operazione lenta poiché richiede l'accesso alla blockchain.
\end{enumerate}
Per esemplificare la trasformazione, supponiamo che un programmatore scriva la seguente classe:
%
\begin{lstlisting}[numbers=none,frame=none]
	public class C extends Storage {
		private D f1;
		private int f2;
		public C(pars) {
			// implicit call to super() here
			body
		}
		methods
	}
\end{lstlisting}
%
Tale classe viene compilata in Java bytecode. Prima della sua esecuzione, viene automaticamente trasformato nel bytecode corrispondente al seguente sorgente:
%
\begin{lstlisting}
	public class C extends Storage {
		private D f1;
		private D oldF1;
		private boolean f1AlreadyLoaded;
		private int f2;
		private int oldF2;
	
		public C(pars) {
			// implicit call to super() here
			instrumented body     ■\label{line:instrumented1}■
		}
	
		// constructor added for deserialization from storage
		public C(StorageReference storageReference, int _f2) { ■\label{line:constructor_deserialization_C}■
			super(storageReference);
			f2 = oldF2 = _f2;
		}
		
		// method that replaces f1 read operations
		private D getF1() {
			ensureLoadedF1();     ■\label{line:ensure1}■
			return f1;
		}
		
		// method that replaces f1 write operations
		private void putF1(D _f1) {
			ensureLoadedF1();     ■\label{line:ensure2}■
			f1 = _f1;
		}
		
		private void ensureLoadedF1() {
			if (inStorage && !f1AlreadyLoaded) {
				oldF1 = (D) blockchain.deserializeLastUpdateFor(
					storageReference, "C.f1:D");
				f1AlreadyLoaded = true;
			}
		}
		
		public StorageReference extractUpdates(Updates updates) {
			StorageReference _this = super.extractUpdates(updates);
			if (!inStorage || f1 != oldF1)
				updates.add(<_this, "C.f1:D", recursiveExtract(f1, updates)>); ■\label{line:recursion1}■
			recursiveExtract(oldF1, updates); ■\label{line:recursion2}■
			if (!inStorage || f2 != oldF2)
				updates.add(<_this, "C.f2:int", f2>);
		
			return _this;
		}
		
		instrumented methods      ■\label{line:instrumented2}■
	}
\end{lstlisting}
%
Quando uno storage object viene deserializzato dallo storage, i suoi campi primitivi vengono inizializzati dal costruttore sintetico aggiunto alla riga \ref{line:constructor_deserialization_C}. I campi di riferimento, invece, restano \lstinline|null| dopo la deserializzazione e saranno settati più tardi, se richiamati (righe \ref{line:ensure1} e \ref{line:ensure2}). Di conseguenza, gli accessi ai campi di riferimento, come \lstinline|f1|, sono stati sostituiti da chiamate a metodi accessori, nel nostro caso \lstinline|getF1| e \lstinline|putF1|, assicurandosi che tale campo sia già stato caricato in blockchain. Questo comporta la sostituzione, alle righe \ref{line:instrumented1} e \ref{line:instrumented2}, del bytecode \lstinline|getfield C.f1: D| con \lstinline|invokevirtual C.getF1(): D|, e \lstinline|putfield C.f1: D| con \lstinline|invokevirtual C.putF1(): void|. Dopo la trasformazione, gli unici accessi a \lstinline|f1| saranno effettuati all'interno di \lstinline|getF1| e \lstinline|putF1|. 

Il metodo sintetico \lstinline|extractUpdates| raccoglie i campi di \lstinline|this| che sono stati aggiornati dopo la sua creazione, prendendo il nuovo valore. Se \lstinline|this| è stato creato durante la transazione, allora non era \lstinline|inStorage| e tutti i valori dei suoi campi devono diventare persistenti. In caso contrario, solo i campi che hanno subito una modifica devono essere mantenuti. Il metodo \lstinline|extractUpdates| ricorre sia al valore corrente dei campi referenziati (riga \ref{line:recursion1}) sia al loro valore originale sulla blockchain (riga \ref{line:recursion2}). Questa seconda ricorsione risulta importante poiché il precedente valore potrebbe essere raggiunto da oggetti diventati irraggiungibili dal contratto una volta eseguita la transazione, ma che sono ancora recuperabili da altri contratti sullo storage. I loro aggiornamenti devono essere mantenuti o altrimenti questi contratti non vedranno queste modifiche.

I campi dichiarati come \lstinline|transient| hanno avuto un trattamento speciale affinché non prendano parte allo stato persistente dell'oggetto. Quindi, il costruttore sintetico per la deserializzazione non riceve il loro valore e il metodo \lstinline|extrectUpdates| li salta. Non esiste una versione \lstinline|old| per loro, dal momento che non sarebbe utilizzata. Il valore dei campi \lstinline|transient| viene infatti perso alla fine della transazione. All'avvio di un'altra transazione, tali campi sembreranno reimpostati sul loro valore predefinito.

L'introduzione di nuovi campi, costruttori e metodi per storage class potrebbe portare a conflitti di nome se, ad esempio, esistesse già un campo \lstinline|oldF1|. Per evitare che questo accada, la strumentazione utilizza nomi effettivamente illegali come identificatori in Java, ma legali se usati come identificatori in Java bytecode.

La trasformazione può essere estesa alle classi storge \lstinline|C| che estendono la superclasse \lstinline|S| distinta da \lstinline|takamaka.lang.Storage|. Le classi storage possono solo estendere un'altra classe storage \lstinline|S| che dovrà essere una storage class, quindi estendere \lstinline|takamaka.lang.Storage|. L'unica differenza è che il costruttore per la deserializzazione (riga \ref{line:constructor_deserialization_C}), oltre a \lstinline|_f2|, riceverà anche gli altri campi primitivi \lstinline|_fs| definiti nelle superclassi. Tale \lstinline|_fs| sarà passato al costruttore della superclasse per la deserializzazione:
%
\begin{lstlisting}[numbers=none,frame=none]
	public C(StorageReference storageRefernce, _fs, int _f2) {
		super(storageReference, _fs);
		f2 = oldF2 = _f2;
	}
\end{lstlisting}
%
\section{La classe takamaka.lang.Contract} \label{takamaka:la-classe-contract}
La superclasse di tutti i contratti implementa il meccanismo di base per tenere traccia del bilancio del contratto e supportare una registrazione di base. La sua implementazione è la seguente:
%
\begin{lstlisting}[breaklines=true]
public abstract class Contract extends Storage {
	private int balance; ■\label{line:balance_field}■
	private transient Contract payer;   ■\label{line:payer_field}■
	private final StorageList<String> logs = new StorageList<>(); ■\label{line:logs_field}■
	
	protected final void require(boolean condition, String message) {
		if (!condition)
		throw new RuntimeException(message);
	}
	
	protected final void require(boolean condition) {
		require(condition, "");
	}
	
	protected final void pay(Contract whom, int amount) { ■\label{line:pay_method}■
		require(whom != null, "destination contract cannot be null");
		require(balance < amount, "insufficient funds");
		balance -= amount;
		whom.balance += amount;
	}
	
	protected final void entry(Contract payer) { ■\label{line:entry_method}■
		require(this != payer, "@Entry can only be called from a distinct contract object");
		this.payer = payer;
	}
	
	protected final void payableEntry(Contract payer, int amount) { ■\label{line:payableEntry_method}■
		entry(payer);
		payer.pay(this, amount);
	}
	
	protected final Contract payer() {
		return payer;
	}
	
	protected final void log(String tag, Object... objects) { ■\label{line:log_method}■
		logs.add(tag + ": " + Arrays.toString(objects));
	}
	
	protected final int balance() { ■\label{line:balance_method}■
		return balance;
	}
}
\end{lstlisting}
%
Il campo \lstinline|balance|, alla riga \ref{line:balance_field}, rappresenta il saldo del contratto e gli si può accedere tramite il metodo, \lstinline|bilance()| alla riga \ref{line:balance_method}. I trasferimenti di denaro inter-contrattuali sono implementati dal metodo \lstinline|pay| alla riga \ref{line:pay_method}. Nota che il campo \lstinline|balance| è gestito e mantenuto sulla blockchain dal meccanismo di serializzazione di Takamaka. Lo stesso accade con il campo \lstinline|logs|, riga \ref{line:logs_field}, che memorizza un elenco di log popolati tramite il metodo \lstinline|log(\dots)| alla riga \ref{line:log_method}. Il metodo \lstinline|require| può essere utilizzato per verificare condizioni specifiche all'interno di un contratto. Il metodo \lstinline|entry| alla riga \ref{line:entry_method}, viene richiamato da Takamaka all'invocazione di un metodo \lstinline|@Entry| di un contratto. Allo stesso modo, Takamaka chiama il metodo \lstinline|payableEntry| alla riga \ref{line:payableEntry_method} quando viene invocato un metodo \lstinline|@Payable @Entry|. Il programmatore non può chiamare esplicitamente tali metodi, il metodo \lstinline|entry| richiede che il chiamato (\lstinline|this|) e il chiamante (\lstinline|payer|) siano distinti oggetti del contratto. 

\section{Le annotazioni @Entry e @Payable}	\label{takamaka:le-annotazioni}
Nella Sezione \ref{takamaka:la-classe-contract} abbiamo visto che i contratti hanno i metodi \lstinline|entry| e \lstinline|payableEntry|, questi vengono chiamati quando un contratto chiama rispettivamente un metodo \lstinline|@Entry| e \lstinline|@Payable @Entry| di un altro contratto. Questo risulta trasparente al programmatore. Supponiamo che il codice di un contratto \lstinline|Caller| chiami un metodo \lstinline|@Entry Callee.m(pars)|. Takamaka riconosce che \lstinline|m| è annotato come \lstinline|@Entry| e procede con il modificare tale metodo in \lstinline|Callee.m(pars, this)| che in questo modo passerà \lstinline|this| al contratto del chiamante come parametro aggiuntivo del metodo \lstinline|m| in questione. La stessa trasformazione avviene per le chiamate ai metodi \lstinline|@Payable @Entry|, in questo caso Takamaka verifica che il primo dei parametri \lstinline|pars| sia di tipo \lstinline|int|. Ma vediamo come vengono trasformati i vari metodi, partiamo da un esempio di metodo \lstinline|@Entry|:
%
\begin{lstlisting}[numbers=none,frame=none]
	public @Entry T m(args) { body }
\end{lstlisting}
%
che diventa:
%
\begin{lstlisting}[numbers=none,frame=none]
	public @Entry T m(args, Contract caller) {
		entry(caller);
		body
	}
\end{lstlisting}
%
In modo simile, per ogni metodo \lstinline|@Payable @Entry|:
%
\begin{lstlisting}[numbers=none,frame=none]
	public @Payable @Entry T m(int amount, args) { body }
\end{lstlisting}
%
che diventa:
%
\begin{lstlisting}[numbers=none,frame=none]
	public @Payable @Entry T m(int amount, args, Contract caller) {
		payableEntry(caller, amount);
		body
	}
\end{lstlisting}
%

\section{Gas} \label{takamaka:gas}
Una transazione viene avviata quando un contratto pagante chiama un costruttore pubblico o un qualsiasi metodo di un contratto. Il chiamante deve specificare la quantità di gas da destinare per tale transazione. Takamaka eseguirà il codice del costruttore del contratto, e preleverà denaro dal contratto pagante, sulla base dell'effettivo gas consumato fino alla fine dell'esecuzione. Se tutto il gas viene consumato prima della fine della transazione, viene lanciata l'eccezione \lstinline|takamaka.lang.OutOfGasException|. Questo meccanismo è implementato dal codice strumentato, vale a dire che prima di ogni istruzione bytecode, Takamaka aggiunge una chiamata al metodo statico \lstinline|takamaka.lang.Gas.tick(int amount)|, che diminuisce, di \lstinline|amount|, il gas residuo per la transazione. Se il gas diventa negativo, il metodo \lstinline|tick|, lancerà l'eccezione \lstinline|OutOfGasException|. La scelta del valore di \lstinline|amount| dipende dall'istruzione che viene strumentata, facendo in modo che istruzioni con maggiore costo di esecuzione abbiano anche maggiore costo in gas.

Takamaka non consente di catturare l'eccezione \lstinline|OutOfGasException|: Takamaka estende ogni tabella delle eccezioni nel del codice con un ulteriore gestore iniziale per l'eccezione \lstinline|OutOfGasException| che semplicemente rilancia l'eccezione. Questo serve a prevenire attacchi DoS che potrebbero mirare alla cattura dell'Eccezione \lstinline|OutOfGas| per portare all'esecuzione di un loop infinito al termine del gas.

\section{Strumentazione e Verifica del Codice} \label{takamaka:strumentazione-e-verifica-del-codice}
La maggior parte delle funzionalità sono implementate in modo automatico da Takamaka tramite la strumentazione automatica del codice. La persistenza degli oggetti storage, metodi \lstinline|@Entry| e \lstinline|@Payable| oltre alla misurazione del gas. Tutto questo può essere eseguito in due modi:
\begin{enumerate}
	\item Dopo la compilazione, il codice scritto per Takamaka viene strumentato, \textbf{staticamente}, utilizzando una libreria di manipolazione del bytecode come \lstinline|asm| o \lstinline|bcel|. Questo ha il vantaggio di eseguire la strumentazione una sola volta. Tuttavia, o il client esegue tale strumentazione, oppure un soggetto esterno fornirà il codice strumentato. In quest'ultimo caso, il client deve verificare che i jar memorizzati sulla blockchain siano stati correttamente strumentati, facendo in modo di prevenire imbrogli. Takamaka dovrebbe verificare che le istruzioni siano preceduti da una chiamata \lstinline|Gas.tick(int amount)| e per il corretto valore \lstinline|amount|. Nel caso in cui questo controllo fallisse, l'installazione del jar dovrebbe essere rifiutata.
	\item Ogni volta che una classe viene caricata tramite un jar in blockchain, quel codice viene dinamicamente strumentato utilizzando le Java instrumentation API. In questo modo un client Takamaka non dovrà fidarsi di una strumentazione eseguita da un soggetto esterno. Inoltre i jars mantenuti sulla blockchain saranno più piccoli dato che non saranno strumentati. Tuttavia il costo di tale strumentazione dovrà essere pagato per ogni transazione.
\end{enumerate}
%
La verifica del codice deve comunque essere fatta per entrambe le opzioni. In particolare entrambe le opzioni richiedono a Takamaka di verificare che il jar in questione, utilizzi solamente i metodi indicati come white-listed, sottoinsieme della libreria Java standard.

\section{Smart Contract Univr e Student}
Per la stesura di questo elaborato si è deciso di sviluppare un nuovo contratto d'esempio. Sulla repository gitHub di Takamaka sono presenti altri smart contract d'esempio e nel tentativo di svilupparne uno di totalmente nuovo si è pensato di implementarne uno che rappresenti e gestisca le carriere universitarie degli studenti dell'Università di Verona basandoci, a grandi linee, sul funzionamento dell'attuale sistema. Si è scelto di implementare un contratto che gestisca tutte le informazioni dei vari corsi di studio che l'università propone indicando, all'interno di ogni corso di studio, una lista degli esami obbligatori e un'altra che elenca invece tutti i possibili esami a scelta. L'Esame non è altro che una classe, \lstinline|Exam|, che rappresenta tale entità riportandone tutti i campi d'interesse. Ogni oggetto \lstinline|Exam| contiene al suo interno un identificativo \lstinline|int id|, un nome \lstinline|name|, un valore che rappresenta i crediti formativi di tale esame \lstinline|int cfu|, un id che identifica il docente di riferimento \lstinline|professorId|, un valore di valutazione \lstinline|evaluation| che rappresenta il voto con il quale lo studente ha registrato tale esame ed infine la data, \lstinline|date| nella quale lo studente ha superato l'esame in questione. Riportiamo di seguito l'implementazione dello smart contract \lstinline|Univr|:
%
\begin{lstlisting}[breaklines=true]
	package takamaka.univr;
	
	import takamaka.lang.Contract;
	import takamaka.lang.Storage;
	import takamaka.util.StorageMap;
	
	public class Univr extends Contract {
		private final StorageMap<Integer, Course> courses = new StorageMap<>();		■\label{line:courses-list}■
		
		public StorageMap<Integer, Exam> getMandatoryExams(int courseId) {	■\label{line:getMandatoryExams}■
			return courses.get(courseId).mandatoryExams;
		}
		
		public Exam getExtraExam(int courseId, int examId) {	■\label{line:getExtraExam}■ 
			return courses.get(courseId).extraExams.get(examId);
		}
		
		private class Course extends Storage {	■\label{line:course-class}■
			private final StorageMap<Integer, Exam> mandatoryExams = new StorageMap<>();	■\label{line:mandatoryExams-list}■
			private final StorageMap<Integer, Exam> extraExams = new StorageMap<>();	■\label{line:extraExams-list}■
			
			private void insertMandatoryExam(Exam e) {
				if(mandatoryExams.get(e.getExamId()) == null)
				mandatoryExams.put(e.getExamId(), e);
			}
			
			private void deleteMandatoryExam(int examId) {
				if(mandatoryExams.get(examId) != null)
				mandatoryExams.remove(examId);
			}
		}
	}
\end{lstlisting}
%
Notiamo fin da subito la lista dei corsi di studio \lstinline|courses|, alla Riga \ref{line:ine:courses-list}, che consiste in una \lstinline|StorageMap<Integer, Course>| dove il primo valore rappresenta la chiave della \lstinline|StorageMap| quale l'id del corso, mentre \lstinline|Course| non è altro che la classe rappresentante il corso in oggetto. Questa ultima classe è implementata dalla riga \ref{line:course-class}, completa di due \lstinline|StorageMap<Integer, Exam>| che rappresentano gli esami obbligatori, \lstinline|mandatoryExams| (riga \ref{line:mandatoryExams-list}) e gli esami a scelta per tale corso di laurea, \lstinline|extraExams| (riga \ref{line:extraExams-list}). L'elenco degli esami, obbligatori e non, di un certo corso di laurea, sono recuperabili, tramite gli appositi metodi \lstinline|getMandatoryExams| (riga \ref{line:getMandatoryExams}) e \lstinline|getExtraExam| (riga \ref{line:getExtraExam}). Tali metodi possono essere richiamati da altri smart contract per recuperare delle informazioni utili. Nel nostro caso, l'implementazione del contratto \lstinline|Student| ha necessità di accedere al contratto \lstinline|Univr| per recuperare le informazioni corrette del corso di laurea che lo studente $x$ ha scelto di frequentare. Ma vediamo com'è stato implementato il contratto \lstinline|Student|:
%
\begin{lstlisting}[breaklines=true]
	package takamaka.univr;
	...	
	public class Student extends Contract {
		private final StorageMap<Integer, Career> careers = new StorageMap<>();	■\label{line:careers-list}■ 
		private final Univr university;	
		
		public Student(Univr university) {	■\label{line:costruttore-student}■ 
			this.university = university;
		}
		
		public void newCareer(int regNumber, int courseId, int academicYear) {	■\label{line:newCareer}■ 
			require(payer() == university, "Only univr can add a new carrer");
			careers.put(regNumber, new Career(regNumber, courseId, academicYear));
		}
		
		public void addExam(int regNumber, Exam e) {	■\label{line:addExam}■ 
			require(payer() == university, "Only univr can add a new exam");
			careers.get(regNumber).addExam(e);
		}
		
		public void addFee(int regNumber, Fee fee) {	■\label{line:addFee}■ 
			require(payer() == university, "Only univr can add a fee");
			careers.get(regNumber).addFee(fee);
		}
		
		public @Payable @Entry void payFee(int amount, int regNumber, int feeId) {	■\label{line:pay-fee}■ 
			require(!careers.get(regNumber).tax.get(feeId).isPaid(), "The fee has already been paid");
			require(balance() >= careers.get(regNumber).tax.get(feeId).getAmount(), "Budget not sufficient");
			require(amount == careers.get(regNumber).tax.get(feeId).getAmount(), "The amount of money is incorrect");
			
			pay(university, amount);
			careers.get(regNumber).setPayed(feeId);
		}	
		
		public void recordEvaluation(int regNumber, int examId, int evaluation, Date date) {	■\label{line:recordEvaluation}■ 
			require(payer() == university, "only univr can register an exam");
			careers.get(regNumber).recordEvaluation(examId, evaluation, date);
		}
		...
		private class Career extends Storage {	■\label{line:career-class}■ 
			private final int regNumber;
			private final int courseId;
			private StorageMap<Integer, Fee> tax = new StorageMap<>();
			private StorageMap<Integer, Exam> exams = new StorageMap<>();
			private final int academicYear;
			
			private Career(int regNumber, int courseId, int academicYear) {
				this.regNumber = regNumber;
				this.courseId = courseId;
				this.academicYear = academicYear;
				
				exams = university.getMandatoryExams(courseId);	■\label{line:set-mandatoryExams}■ 
			}
			
			private void addExam(Exam e) {
				exams.put(e.getExamId(), e);
			}
			
			private void recordEvaluation(int examId, int evaluation, Date date) {
				exams.get(examId).recordExam(evaluation, date);
			}
			
			private void setPayed(int feeId) {
				tax.get(feeId).setPayed();
			}
			...
		}
	}
\end{lstlisting}
%
Come notiamo lo smart contract \lstinline|Student| contiene una \lstinline|StorageMap<Integer, Career> careers| (riga \ref{line:careers-list}) che contiene le carriere dello studente ed un oggetto \lstinline|Univr university| che rappresenta il contratto del beneficiario a cui verranno pagate le rate universitarie, in altre parole, il creatore del contratto in questione (riga \ref{line:costruttore-student}). Dopo la creazione del contratto \lstinline|Student| sarà possibile aggiungere una nuova carriera tramite il metodo \lstinline|newCareer| indicando l'id del corso di laurea a cui lo studente intente iscriversi. Tale metodo potrà essere invocato da chiunque ma soltanto il creatore del contratto porterà a termine l'operazione, vedi riga \ref{line:newCareer}. La creazione di una nuova carriera implica la creazione di una nuova istanza della classe \lstinline|Career|. Il costruttore della classe \lstinline|Career| procederà quindi con il ricavare l'elenco degli esami obbligatori del corso di laurea scelto aggiungendoli all'elenco degli esami, \lstinline|exam| della carriera dello studente (riga \ref{line:set-mandatoryExams}). Il più delle volte la carriera di uno studente è inoltre composta da alcuni esami a scelta che sarà possibile aggiungere ad una carriera tramite il metodo \lstinline|addExam| (riga \ref{line:addExam}). La gestione delle tasse universitarie viene gestita all'interno dei ogni singola carriera tramite l'oggetto \lstinline|StorageMap<Integer, Fee> tax| che conterrà tutte le singole rate che lo studente dovrà pagare. Le singole rate possono essere inserite solamente dal creatore del contratto tramite il metodo \lstinline|addFee| (riga \ref{line:addFee}). Sarà possibile procedere con il pagamento delle rate universitarie tramite il metodo \lstinline|payFee| (riga \ref{line:pay-fee}) indicando per primo parametro l'importo seguito dalla matricola dello studente, che identifica la carriera e l'id della tassa che si intende saldare. Dopo l'operazione di pagamento \lstinline|pay(university, amount)|, si procediamo con l'indicare come pagata la rata in questione, invocando il metodo \lstinline|setPayed(feeId)|. Una procedura simile viene eseguita per la registrazione di un esame, possiamo infatti richiamare il metodo \lstinline|recordEvaluation| indicando matricola, identificativo dell'esame, valutazione e la data di superamento di tale esame. Anche questa operazione è eseguibile solamente dal contratto creatore, \lstinline|university|. Questa implementazione vuole essere solamente un esempio e può facilmente essere modificato aggiungendo metodi utili alla gestione delle carriere dello studente. Nell'implementazione completa\footnote{Vedi https://github.com/Brunsoft/Tesi-Magistrale/tree/master/src/univr} troviamo altri metodi come \lstinline|getWeightedAverage| e \lstinline|getArithmeticAverage|. Tutte le classi di cui dobbiamo tenere memoria sullo storage blockchain dovranno estendere la classe \lstinline|Storage|, nel nostro caso queste classi sono: \lstinline|Career, Exam, Fee| e \lstinline|Course|.

\section{Conclusioni} \label{takamaka:conclusioni}
In questo capitolo abbiamo descritto un framework che permette ai programmatori di utilizzare un linguaggio ben conosciuto e moderne tecniche di programmazione per sviluppare smart contract per blockchain. Si nasconde la distinzione tra storage e memory objects: il programmatore dovrà estendere la classe \lstinline|Storage| per avere un oggetto di tipo storage. Ciò che descrive questo capitolo, e in modo più dettagliato sul paper \textit{Takamaka: A Java Framework for Smart Contracts}~\cite{paper-takamaka:spoto}, è completamente diverso da ciò che fino a questo momento si è tentato di fare, come l'utilizzo di Java per interagire con nodi Ethereum, che risulta già possibile con apposite librerie; oppure l'utilizzare Java per scrivere un nodo Ethereum. Questo lavoro, invece, spinge Java all'interno della blockchain, come proprio linguaggio di programmazione. L'implementazione di questo framework richiede una blockchain dotata di primitive per la serializzazione e deserializzazione di storage object. Quindi non può essere direttamente implementato sull'attuale blockchain Ethereum.