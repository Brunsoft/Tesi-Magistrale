% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT

%************************************************
\chapter{Takamaka}
\label{takamaka-chapter}
%************************************************
Questo capitolo è tratto dall'articolo \cite{paper-takamaka:spoto}, scritto dal docente Nicola Fausto Spoto, nel quale si definisce un framework per la programmazione in Java, di smart contract su blockchain. Tale framework sarà costituito da una routine limitata e da un set di classi che dovranno essere mantenute su blockchain per essere utilizzati dai metodi di contratto e per la misurazione del gas. Questo framework permette inoltre di sfruttare le competenze e gli strumenti già esistenti del mondo Java, al fine di  costruire smart contract in modo semplice e confortevole. 

\section{Un Framework Java per Smart Contract}
Takamaka\footnote{Takamaka è una valle nell'isola della Réunion Francese, dove una rete di cascate converge in un fiume. Questo è simile ai contratti intelligenti Takamaka, cioè a oggetti distinti che collaborano su uno spazio di archiviazione globale condiviso nella blockchain.} è un framework Java per la programmazione di smart contract. Più in particolare, questo framework, è un sottoinsieme di Java, supportato dalla sua libreria runtime \lstinline|takamaka.jar| che include le poche classi che descriveremo in seguito. È anche supportato da una selezione di metodi white-listed della libreria standard di Java. Questi sono metodi la cui esecuzione risulta deterministica. Per esempio, i metodi per la concorrenza non sono permessi, non saranno quindi white-listed in quanto potrebbero portare a comportamenti non deterministici. Il software Takamaka è scritto, verificato ed eseguito come segue:
\begin{description}
	\item[Sviluppo] 
		Le applicazioni Takamaka sono sviluppate come normali applicazioni Java, incluso \lstinline|takamaka.jar|. Non esiste un ambiente di sviluppo speciale per Takamaka. Infatti, è possibile utilizzare qualsiasi IDE o anche solo un compilatore a riga di comando. Il risultato, in ogni caso, sarà l'archivio \lstinline|app.jar| dell'applicazione in fase di sviluppo.
	\item[Verifica] 
		Le classi all'interno di \lstinline|app.jar| vengono verificate per fare in modo che facciano riferimento solo a metodi white-listed. Inoltre, questo passaggio viene verificato che le classi in memoria abbiano componenti di tipo consentito (Sezione 6).
	\item[Installazione]
		L'archivio \lstinline|app.jar| viene installato sulla blockchain, attivando una transazione che installa un jar (Sezione 3).
	\item[Strumentazione]
		Le classi all'interno di \lstinline|app.jar| vengono strumentate. In particolare, le classi di memoria subiscono una trasformazione a livello bytecode che consente ai loro oggetti di essere caricati lentamente in RAM durante l'esecuzione di una transazione e mantenerli aggiornati sulla blockchain, alla sua fine, se sono stati aggiornati (Sezione 6). Inoltre, nel codice viene iniettato un aspetto di misurazione del gas (Sezione 9).
	\item[Esecuzione] 
		Le classi definite in \lstinline|app.jar|, incluse le classi di contratto, vengono istanziate attraverso una transazione che esegue il loro costruttore (Sezione 5). Il risultante \textit{storage reference} può essere usato per richiamare i metodi del nuovo oggetto.
\end{description}
Quello che segue è un esempio di un contratto di crowdfunding scritto a Takamaka. Questo contratto permette a dei finanziatori di versare fondi da devolvere per una campagna. Una volta raggiunta la soglia di una certa campagna i fondi possono essere sbloccati. Tale implementazione consiste in due classi. Vediamo la prima, \lstinline|Founder.java|.
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Storage;
	
	public class Funder extends Storage {
		private final Contract who;
		private final int amount;
		
		public Funder(Contract who, int amount) {
			this.who = who;
			this.amount = amount;
		}
	}
\end{lstlisting}
%
Definisce il finanziatore di una campagna, cioè un contratto che riporta la quantità di denaro che un determinato \lstinline|Founder| intende devolvere per una certa campagna. Dato che questi oggetti devono essere persistenti in blockchain, la classe \lstinline|Founder| deve estendere \lstinline|takamaka.lang.Storage|. Vediamo ora la seconda classe, \lstinline|CrowdFunding.java|:
%
\begin{lstlisting}
	import takamaka.lang.Contract;
	import takamaka.lang.Payable;
	import takamaka.lang.Storage;
	import takamaka.util.StorageList;
	
	public class CrowdFunding extends Contract {
		private final StorageList<Campaign> campaigns = new StorageList<>();  ■\label{line:storage_list}■
		
		public void newCampaign(Contract beneficiary, int goal) {
			campaigns.add(new Campaign(beneficiary, goal));
		}
		
		public @Payable @Entry void contribute(int amount, int campaignID) {  ■\label{line:payable}■
			campaigns.elementAt(campaignID).addFunder(payer(), amount);
		}
		
		public boolean checkGoalReached(int campaignID) {
			return campaigns.elementAt(campaignID).payIfGoalReached();
		}
		
		private class Campaign extends Storage {  ■\label{line:campaign_is_storage}■
			private final Contract beneficiary;
			private final int fundingGoal;
			private final StorageList<Funder> funders = new StorageList<>();
			private int amount;
		
			private Campaign(Contract beneficiary, int fundingGoal) {
				this.beneficiary = beneficiary;
				this.fundingGoal = fundingGoal;
			}
		
			private void addFunder(Contract who, int amount) {
				funders.add(new Funder(who, amount)); this.amount += amount;
			}
		
			private boolean payIfGoalReached() {
				if (amount >= fundingGoal) {
					pay(beneficiary, amount); ■\label{line:pay}■
					amount = 0;
					return true;
				}
				else
					return false;
			}
		}
	}
\end{lstlisting}
%
Rappresenta il contratto del coordinatore del crowdfunding, garantisce che i fondi dedicati ad una campagna non possano essere negati una volta raggiunto l'obiettivo. Consente di avviare una nuova campagna tramite \lstinline|new Campaign|, che mantiene il proprio astato all'interno dell'elenco di campagne avviate. Tale elenco utilizza la classe \lstinline|takamaka.util.StorageList|, che estende \lstinline|Storage|, e può quindi essere presente in blockchain. È possibile contribuire ad una certa campagna tramite \lstinline|contribute|. Viene data la possibilità di verificare se l'obiettivo della campagna è stato raggiunto tramite \lstinline|checkGoalReached|. La campagna è implementata tramite la classe interna \lstinline|Campaign|, in questo modo può fare riferimento al contratto esterno e consentendo di richiamare il metodo \lstinline|pay| del contratto (riga \ref{line:pay}), che trasferisce una data somma di denaro ad un determinato beneficiario. Questo metodo della classe \lstinline|Contract| è \lstinline|final| e di conseguenza non può essere ridefinito, evitando così qualsiasi rischio di reentrancy. È interessante notare che \lstinline|Campaign| estende \lstinline|Storage| (riga \ref{line:campaign_is_storage}) perchè le sue istanze sono contenute all'interno dell'elenco \lstinline|campaigns|, (riga \ref{line:storage_list}) e di conseguenza deve essere persistente nella blockchain.
Alla riga \ref{line:payable} sono presenti le annotazioni \lstinline|@Payable @Entry|. \lstinline|@Entry| indica che si tratta di un punto d'accesso inter-contrattuale e limita il metodo ad appartenere ad una classe che estende \lstinline|takamaka.lang.Contract|. All'interno dei metodi \lstinline|@Entry| è possibile chiamare il metodi \lstinline|payer|, che restituisce il contratto chiamato. In generale, il programmatore utilizzerà \lstinline|@Entry| quando desidera identificare il contratto del metodo richiamato o desidera ricevere denaro da tale contratto. L'annotazione \lstinline|@Payable| può essere aggiunta solamente ad un costruttore o metodo \lstinline|@Entry|. Ciò significa che quest'ultimo riceverà denaro dal contratto \lstinline|payer|. Takamaka trasferirà automaticamente la somma specificata da \lstinline|payer| al contratto di destinazione.

\section{Salvare i file Jar sulla Blockchain}
Takamaka permette di conservare i jars sulla blockchain. Ci sono transazioni che memorizzano jar con riferimenti alle sue dipendenze, se presenti. Il meccanismo ricorda quello che viene fatto attualmente in Ivy o Ant: per memorizzare un jar $j$, viene creata una transazione $t$, che aggiunge $j$ alla blockchain, assieme ai riferimenti ad altre transazioni in cui le sue dipendenze, $d_1, \dots, d_n$, se presenti, sono state precedentemente memorizzate sulla blockchain. Il riferimento a $t$ può quindi essere utilizzato per memorizzare altri jars che dipendono da $j$. Le dipendenze ricorsive tra jars non sono consentite. Le eventuali dipendenze possono essere risolte in modo transitivo o non transitivo. Questo è legato alla costruzione del classpath per l'installazione dello smart contract (Sezione 5). Per memorizzare $j$ sulla blockchain, la transazione memorizzerà i seguenti dati:
%
\[<j, *d_1, t_1, \dots, *d_n, t_n>\]
%
dove $*d_1$ è il riferimento al jar $i$-esimo da cui dipende $j$, $t_1$ è invece un booleano che afferma se la dipendenza è transitiva o meno.